<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Interactive Website - Screen Sharing & Models</title>
  <meta name="description" content="Interactive 3D environment with screen sharing, GLB model loading, and object manipulation">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0; /* Research shows this is critical for mobile */
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #000;
      color: #ffffff;
    }

    #scene-container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    
    /* Research-backed mobile canvas styles */
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none; /* Prevents scrolling on touch */
    }

    .screen {
      position: absolute;
      width: 320px;
      height: 240px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #00ff00;
      border-radius: 8px;
      padding: 20px;
      z-index: 100;
      backdrop-filter: blur(5px);
      cursor: pointer;
    }

    .screen h2 {
      color: #00ff00;
      margin-bottom: 15px;
      text-align: center;
      font-size: 18px;
    }

    .terminal-content {
      font-size: 14px;
      line-height: 1.5;
    }

    .terminal-content p {
      margin-bottom: 8px;
    }

    .controls-info {
      position: absolute;
      bottom: 20px;
      left: 20px;
      z-index: 200;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 5px;
      border: 1px solid #00ff00;
      font-size: 12px;
    }

    .controls-info p {
      margin-bottom: 5px;
      color: #00ff00;
    }

    .model-controls {
      display: none;  /* Hidden by default, shown as popup */
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      display: none;
      min-width: 220px;
      transition: all 0.3s ease;
    }
    
    .model-controls h3 {
      color: #ffffff;
      font-size: 14px;
      font-weight: 600;
      margin: 0 0 12px 0;
      text-align: center;
      opacity: 0.9;
    }
    
    .model-controls .control-row {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      justify-content: center;
    }
    
    .model-controls button {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #ffffff;
      padding: 8px;
      width: 40px;
      height: 40px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }
    
    .model-controls button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }
    
    .model-controls button:active {
      transform: translateY(0);
      background: rgba(255, 255, 255, 0.15);
    }
    
    .model-controls .delete-button {
      background: rgba(255, 77, 77, 0.2);
      border-color: rgba(255, 77, 77, 0.3);
      color: #ff6666;
      width: 100%;
      margin-top: 8px;
    }
    
    .model-controls .delete-button:hover {
      background: rgba(255, 77, 77, 0.3);
      border-color: rgba(255, 77, 77, 0.4);
    }

    .model-controls.visible {
      display: block;
    }

    .model-controls h3 {
      color: #ffffff;
      margin: 0 0 12px 0;
      font-size: 16px;
      font-weight: 600;
    }

    .model-controls button {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #ffffff;
      padding: 8px 12px;
      margin: 4px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.3s ease;
      min-width: 40px;
    }

    .model-controls button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-1px);
    }

    .model-controls button#delete-selected {
      background: rgba(255, 59, 48, 0.2);
      border-color: rgba(255, 59, 48, 0.3);
    }

    .model-controls button#delete-selected:hover {
      background: rgba(255, 59, 48, 0.3);
    }

    .screen-controls {
      display: none;  /* Hidden by default, shown as popup */
    }

    .screen-controls h3 {
      color: #ffffff;
      margin: 0 0 12px 0;
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .screen-controls button {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #ffffff;
      padding: 10px 16px;
      margin: 4px 0;
      border-radius: 10px;
      cursor: pointer;
      font-size: 13px;
      width: 100%;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: center;
    }

    .screen-controls button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-1px);
    }

    .screen-controls input[type="file"] {
      display: none;
    }

    .screen-controls .file-input-wrapper {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #ffffff;
      padding: 10px 16px;
      margin: 4px 0;
      border-radius: 10px;
      cursor: pointer;
      font-size: 13px;
      width: 100%;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: center;
    }

    .screen-controls .file-input-wrapper:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-1px);
    }

    .screen-controls .volume-control {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 12px;
      padding: 8px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
    }

    .screen-controls input[type="range"] {
      appearance: none;
      background: transparent;
      cursor: pointer;
      height: 20px;
      flex: 1;
    }

    .screen-controls input[type="range"]::-webkit-slider-track {
      background: rgba(255, 255, 255, 0.2);
      height: 4px;
      border-radius: 2px;
    }

    .screen-controls input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      background: #ffffff;
      height: 14px;
      width: 14px;
      border-radius: 50%;
      cursor: pointer;
      margin-top: -5px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }


    #video-element {
      display: none;
    }

    .drag-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(74, 144, 226, 0.1);
      border: 3px dashed rgba(74, 144, 226, 0.5);
      z-index: 300;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: #ffffff;
      pointer-events: none;
      backdrop-filter: blur(2px);
    }

    .drag-overlay.active {
      display: flex;
    }

    canvas {
      display: block;
    }

    /* Mobile Debug Panel */
    #mobile-debug-panel {
      position: fixed;
      bottom: 70px;
      left: 10px;
      width: 90%;
      max-width: 350px;
      max-height: 50vh;
      background: rgba(0, 0, 0, 0.95);
      border: 1px solid rgba(74, 144, 226, 0.5);
      border-radius: 8px;
      padding: 15px;
      font-size: 11px;
      font-family: 'Courier New', monospace;
      overflow-y: auto;
      z-index: 10000;
      display: none;
      backdrop-filter: blur(10px);
    }
    
    #mobile-debug-panel.visible {
      display: block;
    }
    
    #mobile-debug-panel h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
      color: #4a90e2;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      padding-bottom: 5px;
    }
    
    #mobile-debug-panel .debug-section {
      margin-bottom: 12px;
      padding: 8px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
    }
    
    #mobile-debug-panel .debug-section h4 {
      margin: 0 0 5px 0;
      color: #4a90e2;
      font-size: 12px;
    }
    
    #mobile-debug-panel .debug-row {
      display: flex;
      justify-content: space-between;
      margin: 2px 0;
    }
    
    #mobile-debug-panel .debug-label {
      color: #888;
      flex: 0 0 45%;
    }
    
    #mobile-debug-panel .debug-value {
      color: #fff;
      flex: 0 0 55%;
      text-align: right;
      word-break: break-all;
    }
    
    #mobile-debug-panel .debug-warning {
      color: #ff9800;
    }
    
    #mobile-debug-panel .debug-error {
      color: #f44336;
    }
    
    #mobile-debug-panel .debug-success {
      color: #4caf50;
    }
    
    #debug-toggle-btn {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      color: rgba(255, 255, 255, 0.4);
      font-size: 16px;
      cursor: pointer;
      z-index: 10001;
      display: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      transition: all 0.3s ease;
      line-height: 40px;
      padding: 0;
      text-align: center;
      pointer-events: auto;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    
    #debug-toggle-btn:hover {
      background: rgba(255, 255, 255, 0.12);
      color: rgba(255, 255, 255, 0.6);
    }
    
    #debug-toggle-btn:active {
      transform: scale(0.95);
    }

    @media (max-width: 768px) {
      .screen {
        width: 280px;
        height: 200px;
        padding: 15px;
      }
      
      
      .screen-controls {
        width: 200px;
      }
    }

    /* Glass Morphism Menu Styles */
    .glass-menu {
      position: absolute;
      top: 75px;  /* Moved down to avoid toggle button */
      left: 20px;
      z-index: 400;
      display: flex;
      flex-direction: column;  /* Single column layout */
      align-items: center;  /* Center icons */
      gap: 10px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 16px;
      padding: 6px;  /* Minimal padding */
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      transform-origin: top left;
      width: auto;  /* Auto-size to content */
      box-sizing: border-box;
    }
    
    /* Popup panels for menu items */
    .menu-popup {
      position: fixed;  /* Use fixed positioning instead */
      top: 75px;  /* Same top as menu */
      left: 90px;  /* 20px (menu left) + 60px (menu width) + 10px (gap) */
      min-width: 200px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 16px;
      padding: 15px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      opacity: 0;
      transform: translateX(-10px);
      pointer-events: none;
      transition: all 0.3s ease;
      z-index: 399;
    }
    
    /* Style buttons in popups */
    .menu-popup button {
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      color: rgba(255, 255, 255, 0.9);
      padding: 10px 16px;
      border-radius: 12px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      width: 100%;
      margin: 4px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .menu-popup button:hover {
      background: rgba(255, 255, 255, 0.12);
      border-color: rgba(255, 255, 255, 0.25);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }
    
    .menu-popup button:active {
      transform: translateY(0);
      background: rgba(255, 255, 255, 0.1);
    }
    
    /* Style file input wrappers in popups */
    .menu-popup .file-input-wrapper {
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      color: rgba(255, 255, 255, 0.9);
      padding: 10px 16px;
      border-radius: 12px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      width: 100%;
      margin: 4px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .menu-popup .file-input-wrapper:hover {
      background: rgba(255, 255, 255, 0.12);
      border-color: rgba(255, 255, 255, 0.25);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }
    
    .menu-popup.active {
      opacity: 1;
      transform: translateX(0);
      pointer-events: auto;
    }
    
    .menu-popup h3 {
      color: #ffffff;
      font-size: 14px;
      font-weight: 600;
      margin: 0 0 12px 0;
    }
    
    .glass-menu.collapsed {
      opacity: 0;
      transform: scale(0);
      pointer-events: none;
    }
    
    /* Toggle buttons for corners */
    .corner-toggle {
      position: fixed;
      width: 44px;
      height: 44px;
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 401;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }
    
    .corner-toggle:hover {
      background: rgba(255, 255, 255, 0.12);
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    .corner-toggle svg {
      width: 20px;
      height: 20px;
      stroke: rgba(255, 255, 255, 0.8);
      stroke-width: 2;
      fill: none;
    }
    
    #menu-toggle {
      top: 20px;
      left: 20px;
    }
    
    #users-toggle {
      top: 20px;
      right: 20px;
    }
    
    /* Mobile layout for menu buttons only */
    @media (max-width: 768px) {
      .glass-menu .glass-button {
        width: 38px;
        height: 38px;
        font-size: 16px;
      }
    }

    .glass-button {
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      color: #ffffff;
      transition: all 0.3s ease;
      position: relative;
      margin: 0;  /* Ensure no default margins */
      flex-shrink: 0;  /* Prevent button from shrinking */
    }

    .glass-button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
    }

    .glass-button .tooltip {
      position: absolute;
      bottom: -35px;
      left: 50%;
      transform: translateX(-50%) scale(0);
      background: rgba(0, 0, 0, 0.9);
      color: #ffffff;
      padding: 6px 12px;
      border-radius: 8px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      transition: all 0.3s ease;
      pointer-events: none;
      font-weight: 500;
    }

    .glass-button:hover .tooltip {
      transform: translateX(-50%) scale(1);
      opacity: 1;
    }

    /* User List Styles */
    .user-list {
      position: fixed;
      top: 20px;  /* Same position as toggle button */
      right: 20px;
      z-index: 402;  /* Higher than toggle button */
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 16px;
      padding: 15px 20px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      min-width: 150px;
      transition: all 0.3s ease;
      transform-origin: top right;
    }
    
    .user-list.collapsed {
      opacity: 0;
      transform: scale(0);
      pointer-events: none;
    }

    .user-list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      gap: 15px;
    }

    .user-list h3 {
      margin: 0;
      color: #ffffff;
      font-size: 14px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .user-list-close {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: #ffffff;
      font-size: 20px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
    }
    
    .user-list-close:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.5);
    }
    
    .user-list.collapsed {
      min-width: auto;
      padding: 10px 15px;
    }
    
    .user-list.collapsed .user-list-body {
      display: none;
    }
    
    .user-list.collapsed .user-list-header {
      margin-bottom: 0;
    }

    .user-item {
      margin: 6px 0;
      color: #ffffff;
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.05);
    }

    .user-item.self {
      background: rgba(74, 144, 226, 0.2);
      font-weight: 600;
    }

    .user-count {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.7);
      margin-left: 4px;
    }

    /* Chat Interface Styles */
    .chat-container {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 250px;
      z-index: 300;
      background: transparent;
      display: flex;
      flex-direction: column;
      transition: all 0.3s ease;
      pointer-events: none;
    }
    
    .chat-container > * {
      pointer-events: auto;
    }

    .chat-header {
      display: none;
    }

    .chat-messages {
      max-height: 120px;
      overflow-y: auto;
      padding: 0 0 4px 0;
      font-size: 14px;
      line-height: 1.2;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }

    .chat-messages::-webkit-scrollbar {
      width: 6px;
      display: none;
    }
    
    .chat-messages:hover::-webkit-scrollbar {
      display: block;
    }

    .chat-messages::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 3px;
    }

    .chat-messages::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
    }

    .chat-message {
      margin: 1px 0;
      word-wrap: break-word;
      background: transparent;
      padding: 1px 0;
      color: #ffffff;
      font-weight: 600;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(0, 0, 0, 0.6);
    }

    .chat-message .username {
      color: #4aff4a;
      font-weight: 700;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.9), 0 0 10px rgba(74, 255, 74, 0.3);
    }

    .chat-message .timestamp {
      display: none;
    }

    .chat-message .content {
      color: #ffffff;
      margin-left: 5px;
      font-size: 14px;
      font-weight: 600;
    }

    .chat-input-container {
      border-top: none;
      padding: 0;
      display: flex;
      gap: 8px;
      margin-top: 4px;
    }

    .chat-input {
      flex: 1;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #ffffff;
      padding: 8px 12px;
      border-radius: 12px;
      font-size: 16px;  /* 16px prevents zoom on iOS */
      transition: all 0.3s ease;
      -webkit-appearance: none;  /* Remove iOS styling */
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      min-width: 0;  /* Allow input to shrink properly */
    }

    .chat-input:focus {
      outline: none;
      border-color: rgba(74, 144, 226, 0.5);
      background: rgba(255, 255, 255, 0.15);
    }

    .chat-send {
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: #ffffff;
      padding: 8px 12px;
      border-radius: 12px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.3s ease;
      flex-shrink: 0;  /* Prevent button from shrinking */
      -webkit-tap-highlight-color: transparent;  /* Remove tap highlight */
      touch-action: manipulation;  /* Better touch handling */
    }

    .chat-send:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.5);
    }

    .chat-toggle {
      position: absolute;
      bottom: 20px;
      right: 280px;  /* Position next to narrower chat (250px + 30px gap) */
      z-index: 301;
      width: 28px;
      height: 28px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;  /* Make it circular */
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      padding: 0;
      line-height: 1;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .chat-toggle:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.5);
      transform: scale(1.1);
    }
    
    .chat-toggle.show-chat {
      /* When chat is hidden, show chat icon */
    }
    
    .chat-toggle.hide-chat {
      /* When chat is shown, show X icon */
      font-size: 20px;
    }

    .chat-container.hidden {
      display: none;
    }

    /* Help Dialog Styles */
    .help-dialog {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 400px;
      max-width: 90vw;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      z-index: 500;
      display: none;
    }

    .help-dialog.visible {
      display: block;
    }

    .help-dialog h2 {
      color: #ffffff;
      margin: 0 0 16px 0;
      font-size: 20px;
      font-weight: 600;
    }

    .help-dialog .help-section {
      margin-bottom: 16px;
    }

    .help-dialog h3 {
      color: #4a90e2;
      font-size: 14px;
      margin: 0 0 8px 0;
      font-weight: 600;
    }

    .help-dialog p {
      color: #ffffff;
      font-size: 13px;
      line-height: 1.5;
      margin: 4px 0;
    }

    .help-dialog .key {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
    }

    .help-close {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 32px;
      height: 32px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      color: #ffffff;
      transition: all 0.3s ease;
    }

    .help-close:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    
    .object-list-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 15px;
      margin: 5px 0;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .object-list-item:hover {
      background: rgba(255, 255, 255, 0.15);
    }
    
    .object-list-item span {
      color: #ffffff;
      font-size: 14px;
    }
    
    .object-delete-btn {
      background: rgba(255, 59, 48, 0.2);
      border: 1px solid rgba(255, 59, 48, 0.3);
      color: #ffffff;
      padding: 5px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.3s ease;
    }
    
    .object-delete-btn:hover {
      background: rgba(255, 59, 48, 0.3);
      transform: translateY(-1px);
    }

    /* Welcome Dialog Styles */
    .welcome-dialog {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 350px;
      max-width: 90vw;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 16px;
      padding: 32px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      z-index: 600;
      text-align: center;
      pointer-events: auto; /* Ensure dialog is interactive */
    }

    .welcome-dialog h2 {
      color: #ffffff;
      margin: 0 0 8px 0;
      font-size: 24px;
      font-weight: 600;
    }

    .welcome-dialog p {
      color: rgba(255, 255, 255, 0.8);
      margin: 0 0 24px 0;
      font-size: 14px;
    }

    /* High-tech loading animation */
    .loading-container {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10002;
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 24px;
    }
    
    .loading-container.active {
      display: flex;
    }
    
    .tech-loader {
      width: 120px;
      height: 120px;
      position: relative;
    }
    
    .tech-loader .core {
      position: absolute;
      width: 40px;
      height: 40px;
      background: linear-gradient(135deg, #00ffcc, #0099ff);
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 40px #00ffcc, 0 0 80px #0099ff;
      animation: corePulse 2s ease-in-out infinite;
    }
    
    .tech-loader .ring {
      position: absolute;
      border: 2px solid transparent;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: inset 0 0 20px rgba(0, 255, 204, 0.2);
    }
    
    .tech-loader .ring:nth-child(2) {
      width: 60px;
      height: 60px;
      border-top-color: #00ffcc;
      animation: spin 1.5s linear infinite;
    }
    
    .tech-loader .ring:nth-child(3) {
      width: 80px;
      height: 80px;
      border-right-color: #0099ff;
      animation: spinReverse 2s linear infinite;
    }
    
    .tech-loader .ring:nth-child(4) {
      width: 100px;
      height: 100px;
      border-bottom-color: #00ccff;
      animation: spin 2.5s linear infinite;
    }
    
    .tech-loader .ring:nth-child(5) {
      width: 120px;
      height: 120px;
      border-left-color: rgba(0, 153, 255, 0.5);
      animation: spinReverse 3s linear infinite;
    }
    
    .loading-text {
      color: #ffffff;
      font-size: 18px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 3px;
      text-align: center;
      opacity: 0.9;
      animation: textGlow 2s ease-in-out infinite;
    }
    
    .loading-subtext {
      color: rgba(255, 255, 255, 0.6);
      font-size: 14px;
      text-align: center;
      margin-top: -16px;
      animation: fadeInOut 3s ease-in-out infinite;
    }
    
    .loading-progress {
      width: 200px;
      height: 2px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      overflow: hidden;
      position: relative;
    }
    
    .loading-progress-bar {
      position: absolute;
      height: 100%;
      width: 30%;
      background: linear-gradient(90deg, transparent, #00ffcc, transparent);
      animation: progressScan 1.5s ease-in-out infinite;
    }
    
    @keyframes corePulse {
      0%, 100% {
        transform: translate(-50%, -50%) scale(1);
        box-shadow: 0 0 40px #00ffcc, 0 0 80px #0099ff;
      }
      50% {
        transform: translate(-50%, -50%) scale(1.2);
        box-shadow: 0 0 60px #00ffcc, 0 0 120px #0099ff;
      }
    }
    
    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }
    
    @keyframes spinReverse {
      0% { transform: translate(-50%, -50%) rotate(360deg); }
      100% { transform: translate(-50%, -50%) rotate(0deg); }
    }
    
    @keyframes textGlow {
      0%, 100% {
        text-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
      }
      50% {
        text-shadow: 0 0 20px rgba(0, 255, 204, 0.8), 0 0 30px rgba(0, 153, 255, 0.6);
      }
    }
    
    @keyframes fadeInOut {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 0.8; }
    }
    
    @keyframes progressScan {
      0% { left: -30%; }
      100% { left: 100%; }
    }

    .welcome-input {
      width: 100%;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #ffffff;
      padding: 12px 16px;
      border-radius: 12px;
      font-size: 16px;
      text-align: center;
      margin-bottom: 20px;
      transition: all 0.3s ease;
      -webkit-appearance: none; /* Remove iOS default styling */
      -webkit-tap-highlight-color: transparent; /* Remove tap highlight */
      touch-action: manipulation; /* Better touch handling */
    }

    .welcome-input:focus {
      outline: none;
      border-color: rgba(74, 144, 226, 0.5);
      background: rgba(255, 255, 255, 0.15);
    }

    .welcome-input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }

    .welcome-button {
      background: rgba(74, 144, 226, 0.3);
      border: 1px solid rgba(74, 144, 226, 0.4);
      color: #ffffff;
      padding: 12px 32px;
      border-radius: 12px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s ease;
      min-width: 120px;
      -webkit-tap-highlight-color: transparent; /* Remove tap highlight on iOS */
      touch-action: manipulation; /* Prevent double-tap zoom */
    }

    .welcome-button:hover {
      background: rgba(74, 144, 226, 0.4);
      transform: translateY(-2px);
      box-shadow: 0 4px 16px rgba(74, 144, 226, 0.3);
    }

    .welcome-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 599;
      pointer-events: auto; /* Ensure overlay is interactive */
    }

    /* Visitor Counter Styles */
    .visitor-counter {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      padding: 8px 24px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      z-index: 400;
      transition: all 0.3s ease;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    .visitor-counter:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateX(-50%) translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
    }

    .visitor-count {
      color: #ffffff;
      font-size: 14px;
      font-weight: 600;
      text-align: center;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .visitor-count-number {
      color: #4a90e2;
      font-size: 16px;
      font-weight: 700;
    }

    @media (max-width: 768px) {
      .visitor-counter {
        top: 65px; /* Move below menu on mobile */
        padding: 6px 20px;
      }

      .visitor-count {
        font-size: 12px;
      }

      .visitor-count-number {
        font-size: 14px;
      }

      .user-list {
        top: 10px;
        right: 10px;
        padding: 10px 15px;
        min-width: 120px;
      }

      .user-list h3 {
        font-size: 12px;
      }
      
      .user-list-close {
        width: 20px;
        height: 20px;
        font-size: 16px;
      }

      .user-item {
        font-size: 11px;
      }

      .chat-container {
        width: calc(100vw - 20px);
        max-width: 250px;
        bottom: 10px;
        right: 10px;
      }
      
      .chat-input-container {
        gap: 6px;  /* Smaller gap on mobile */
      }
      
      .chat-send {
        padding: 8px 10px;  /* Smaller padding on mobile */
        font-size: 12px;
      }

      .chat-toggle {
        right: 270px;  /* Next to narrower mobile chat */
        bottom: 10px;
        width: 24px;
        height: 24px;
        font-size: 14px;
      }

      .help-dialog {
        width: calc(100vw - 40px);
        padding: 20px;
      }
    }

    /* Upload spinner animation */
    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: #4a90e2;
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="scene-container">
    <div class="screen" id="interactive-screen" style="display: none;">
      <h2>3D Model Loader</h2>
      <div class="terminal-content">
        <p>🖥️ Large screen sharing available!</p>
        <p>📦 Drag & drop GLB files here!</p>
        <p>Click to enter or press ENTER</p>
        <p>WASD to move, mouse to look</p>
      </div>
    </div>
    <div class="drag-overlay" id="drag-overlay">
      <div>Drop GLB file to load 3D model</div>
    </div>
  </div>
  
  <!-- Corner Toggle Buttons -->
  <button class="corner-toggle" id="menu-toggle" aria-label="Toggle Menu">
    <svg viewBox="0 0 24 24">
      <rect x="4" y="5" width="16" height="2" rx="1"/>
      <rect x="4" y="11" width="16" height="2" rx="1"/>
      <rect x="4" y="17" width="16" height="2" rx="1"/>
    </svg>
  </button>
  
  <button class="corner-toggle" id="users-toggle" aria-label="Toggle Users">
    <svg viewBox="0 0 24 24">
      <circle cx="12" cy="8" r="3"/>
      <path d="M12 14c-4 0-7 2-7 4v2h14v-2c0-2-3-4-7-4z"/>
    </svg>
  </button>
  
  <!-- Glass Menu -->
  <div class="glass-menu collapsed" id="glass-menu">
    <button class="glass-button" id="menu-home" data-popup="home-popup">
      🏠
      <span class="tooltip">Home</span>
    </button>
    <button class="glass-button" id="menu-screen" data-popup="screen-popup">
      🖥️
      <span class="tooltip">Screen Share</span>
    </button>
    <button class="glass-button" id="menu-objects" data-popup="objects-popup">
      📦
      <span class="tooltip">Load GLB Model</span>
    </button>
    <button class="glass-button" id="menu-help" data-popup="help-popup">
      ❓
      <span class="tooltip">Help</span>
    </button>
  </div>
  
  <!-- Popup Panels (moved outside menu container) -->
  <div class="menu-popup" id="home-popup">
      <h3>🏠 Home</h3>
      <p style="color: #fff; font-size: 12px;">Welcome to the 3D Multi-User World!</p>
      <p style="color: rgba(255,255,255,0.7); font-size: 11px;">Click anywhere to close</p>
    </div>
    
    <div class="menu-popup" id="screen-popup">
      <h3>🖥️ Screen Share</h3>
      <button id="share-screen">🖥️ Share Desktop</button>
      <button id="stop-sharing" style="display: none;">⏹️ Stop Sharing</button>
      <label class="file-input-wrapper">
        📁 Load Video File
        <input type="file" id="video-upload" accept="video/*" style="display: none;" />
      </label>
      <button id="clear-screen">🧹 Clear Screen</button>
    </div>
    
    <div class="menu-popup" id="objects-popup">
      <h3>📦 3D Objects</h3>
      <label class="file-input-wrapper">
        📦 Load Local GLB Model
        <input type="file" id="glb-upload" accept=".glb,.gltf" style="display: none;" />
      </label>
      <label class="file-input-wrapper" style="margin-top: 10px; background: rgba(255, 165, 0, 0.2); border: 1px solid rgba(255, 165, 0, 0.4);">
        ☁️ Upload GLB to Cloud
        <input type="file" id="glb-cloud-upload" accept=".glb" style="display: none;" />
      </label>
      <label class="file-input-wrapper" style="margin-top: 10px; background: rgba(74, 144, 226, 0.2); border: 1px solid rgba(74, 144, 226, 0.4);">
        🏠 Replace Room Model
        <input type="file" id="room-upload" accept=".glb" style="display: none;" />
      </label>
      <div id="upload-progress" style="display: none; margin-top: 12px; padding: 10px; background: rgba(255, 255, 255, 0.1); border-radius: 8px;">
        <div style="display: flex; align-items: center; gap: 8px;">
          <div class="spinner"></div>
          <span id="upload-status">Uploading...</span>
        </div>
        <div style="width: 100%; background: rgba(255, 255, 255, 0.2); border-radius: 4px; height: 4px; margin-top: 8px;">
          <div id="upload-progress-bar" style="width: 0%; background: #4a90e2; height: 100%; border-radius: 4px; transition: width 0.3s ease;"></div>
        </div>
      </div>
      <div id="object-controls" style="display: none; margin-top: 12px;">
        <div style="display: flex; gap: 8px; margin: 8px 0;">
          <button id="move-up" style="flex: 1;">↑</button>
          <button id="move-down" style="flex: 1;">↓</button>
        </div>
        <div style="display: flex; gap: 8px; margin: 8px 0;">
          <button id="move-left" style="flex: 1;">←</button>
          <button id="move-right" style="flex: 1;">→</button>
        </div>
        <button id="delete-object" style="width: 100%; margin: 8px 0; background: rgba(255,77,77,0.15); border-color: rgba(255,77,77,0.3);">🗑️ Delete</button>
      </div>
    </div>
    
  <div class="menu-popup" id="help-popup">
    <h3>❓ Help</h3>
    <p style="color: rgba(255,255,255,0.8); font-size: 12px; margin: 8px 0;">
      <strong>Controls:</strong><br>
      • WASD - Move<br>
      • Mouse - Look<br>
      • Click - Select object<br>
      • ESC - Exit fullscreen
    </p>
  </div>
  
  <!-- Visitor Counter (Disabled) -->
  <!-- <div class="visitor-counter" id="visitor-counter">
    <div class="visitor-count">
      <span class="visitor-count-number" id="visitor-count-number">0</span>
      <span>visitors</span>
    </div>
  </div> -->
  
  <!-- Old controls removed - now using popup system -->

  
  <video id="video-element" autoplay controls muted="false" volume="1.0" style="display: none;"></video>
  
  <div class="model-controls" id="model-controls">
    <h3 id="selected-object-name">Object Controls</h3>
    <div class="control-row">
      <button id="move-up" title="Move Up">↑</button>
      <button id="move-down" title="Move Down">↓</button>
      <button id="move-left" title="Move Left">←</button>
      <button id="move-right" title="Move Right">→</button>
    </div>
    <div class="control-row">
      <button id="move-forward" title="Move Forward">▲</button>
      <button id="move-backward" title="Move Backward">▼</button>
      <button id="scale-up" title="Scale Up">+</button>
      <button id="scale-down" title="Scale Down">-</button>
    </div>
    <div class="control-row">
      <button id="rotate-y" title="Rotate">↻</button>
      <button id="reset-object" title="Reset">⟲</button>
      <button id="deselect-object" title="Deselect">✖</button>
    </div>
    <button id="delete-selected" class="delete-button">🗑️ Delete Object</button>
  </div>

  <!-- User List in Top Right -->
  <div class="user-list collapsed" id="user-list">
    <div class="user-list-header">
      <h3>👥 Users Online <span class="user-count" id="user-count-badge">(1)</span></h3>
      <button class="user-list-close" id="user-list-close">×</button>
    </div>
    <div class="user-list-body" id="user-list-body">
      <div id="user-list-content">
        <div class="user-item self" id="current-user">Loading...</div>
      </div>
    </div>
  </div>

  <!-- Chat Interface -->
  <div class="chat-container" id="chat-container">
    <div class="chat-messages" id="chat-messages">
      <!-- Messages will be added here -->
    </div>
    <div class="chat-input-container">
      <input type="text" class="chat-input" id="chat-input" placeholder="Type message..." maxlength="200">
      <button class="chat-send" id="chat-send">Send</button>
    </div>
  </div>

  <!-- Chat Toggle Button -->
  <button class="chat-toggle hide-chat" id="chat-toggle">×</button>

  <!-- Help Dialog -->
  <div class="help-dialog" id="help-dialog">
    <button class="help-close" id="help-close">✖</button>
    <h2>Controls & Help</h2>
    
    <div class="help-section">
      <h3>Movement</h3>
      <p><span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span> - Move around</p>
      <p><span class="key">Mouse</span> - Look around</p>
      <p><span class="key">ENTER</span> - Hide/show screen</p>
    </div>
    
    <div class="help-section">
      <h3>Object Manipulation</h3>
      <p><span class="key">Click</span> - Select object</p>
      <p><span class="key">R</span> - Reset object</p>
      <p><span class="key">Q</span> - Rotate object</p>
      <p><span class="key">E</span> / <span class="key">C</span> - Scale up/down</p>
      <p><span class="key">DEL</span> - Delete object</p>
      <p>Drag GLB files to load 3D models</p>
    </div>
    
    <div class="help-section">
      <h3>Features</h3>
      <p>🖥️ Screen sharing with other users</p>
      <p>📦 Load and manipulate 3D objects</p>
      <p>💬 Real-time chat with persistence</p>
      <p>👥 See other users as avatars</p>
    </div>
  </div>
  
  <!-- Objects List Modal -->
  <div class="help-dialog" id="objects-list-dialog">
    <button class="help-close" id="objects-list-close">✖</button>
    <h2>📦 Objects in Space</h2>
    
    <div id="objects-list-container" style="max-height: 400px; overflow-y: auto; margin-top: 20px;">
      <!-- Objects will be populated here -->
    </div>
  </div>

  <!-- Welcome Dialog -->
  <div class="welcome-overlay" id="welcome-overlay" style="display: none;"></div>
  <div class="welcome-dialog" id="welcome-dialog" style="display: none;">
    <h2>Welcome</h2>
    <p>Enter your name to join</p>
    <input type="text" class="welcome-input" id="welcome-input" placeholder="Your name" maxlength="20" autocomplete="off">
    <button class="welcome-button" id="welcome-button">Join</button>
  </div>

  <!-- High-tech loading animation -->
  <div class="loading-container" id="loading-container">
    <div class="tech-loader">
      <div class="core"></div>
      <div class="ring"></div>
      <div class="ring"></div>
      <div class="ring"></div>
      <div class="ring"></div>
    </div>
    <div class="loading-text">Initializing</div>
    <div class="loading-subtext">Loading virtual environment...</div>
    <div class="loading-progress">
      <div class="loading-progress-bar"></div>
    </div>
  </div>
  
  <!-- Mobile Debug Panel -->
  <button id="debug-toggle-btn" aria-label="Debug Console">⚙</button>
  <div id="mobile-debug-panel">
    <h3>Mobile Debug Info</h3>
    <div id="debug-content"></div>
    <div style="margin-top: 10px; display: flex; gap: 10px;">
      <button onclick="window.copyDebugInfo && window.copyDebugInfo();" style="padding: 5px 10px; background: #28a745; color: white; border: none; border-radius: 4px;">📋 Copy All</button>
      <button onclick="this.parentElement.parentElement.classList.remove('visible');" style="padding: 5px 10px; background: #4a90e2; color: white; border: none; border-radius: 4px;">Close</button>
    </div>
  </div>
  
  <script src="https://unpkg.com/socket.io-client@4.7.2/dist/socket.io.js"></script>
  <script src="https://unpkg.com/simple-peer@9.11.1/simplepeer.min.js"></script>
  
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
      }
    }
  </script>
  
  <script src="glb-processor-client.js"></script>
  <script src="./spaces-config.js"></script>
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

    console.log('Starting 3D Interactive Website...');
    
    // Initialize GLB processor
    const glbProcessor = new ClientGLBProcessor(THREE, GLTFLoader);
    console.log('GLB Processor initialized');

    // Enhanced mobile detection - define FIRST
    const isMobileEarly = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // Check for real iOS even if Chrome masks it - define globally for use everywhere
    const isRealIOS = /iPhone|iPad|iPod/.test(navigator.userAgent) || 
                      /iPhone|iPad|iPod/.test(navigator.platform) ||
                      (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    
    // Mobile Debug Panel Management
    let debugInfo = {
      platform: {},
      webgl: {},
      textures: [],
      errors: [],
      performance: {},
      logs: []  // Store all console logs
    };
    
    // Override console.log to capture logs
    const originalConsoleLog = console.log;
    console.log = function(...args) {
      originalConsoleLog.apply(console, args);
      if (isMobileEarly) {
        debugInfo.logs.push(args.map(arg => 
          typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
        ).join(' '));
        // Keep only last 100 logs
        if (debugInfo.logs.length > 100) {
          debugInfo.logs.shift();
        }
      }
    };
    
    function updateDebugPanel() {
      if (!isMobileEarly) return;
      
      const debugContent = document.getElementById('debug-content');
      if (!debugContent) return;
      
      let html = '';
      
      // Platform Info
      html += '<div class="debug-section"><h4>Platform</h4>';
      Object.entries(debugInfo.platform).forEach(([key, value]) => {
        html += `<div class="debug-row"><span class="debug-label">${key}:</span><span class="debug-value">${value}</span></div>`;
      });
      html += '</div>';
      
      // WebGL Info
      html += '<div class="debug-section"><h4>WebGL Capabilities</h4>';
      Object.entries(debugInfo.webgl).forEach(([key, value]) => {
        const className = key.includes('max') && value < 2048 ? 'debug-warning' : 'debug-value';
        html += `<div class="debug-row"><span class="debug-label">${key}:</span><span class="${className}">${value}</span></div>`;
      });
      html += '</div>';
      
      // Texture Info
      if (debugInfo.textures.length > 0) {
        html += '<div class="debug-section"><h4>Textures Loaded</h4>';
        debugInfo.textures.forEach(tex => {
          const statusClass = tex.success ? 'debug-success' : 'debug-error';
          html += `<div class="debug-row"><span class="debug-label">${tex.name}:</span><span class="${statusClass}">${tex.status}</span></div>`;
        });
        html += '</div>';
      }
      
      // Errors
      if (debugInfo.errors.length > 0) {
        html += '<div class="debug-section"><h4>Errors</h4>';
        debugInfo.errors.forEach(error => {
          html += `<div class="debug-error">${error}</div>`;
        });
        html += '</div>';
      }
      
      // Performance
      if (Object.keys(debugInfo.performance).length > 0) {
        html += '<div class="debug-section"><h4>Performance</h4>';
        Object.entries(debugInfo.performance).forEach(([key, value]) => {
          html += `<div class="debug-row"><span class="debug-label">${key}:</span><span class="debug-value">${value}</span></div>`;
        });
        html += '</div>';
      }
      
      // Console Logs (last 20)
      if (debugInfo.logs.length > 0) {
        html += '<div class="debug-section"><h4>Console Logs (Recent)</h4>';
        html += '<div style="max-height: 200px; overflow-y: auto; font-size: 10px; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 4px;">';
        debugInfo.logs.slice(-20).forEach(log => {
          html += `<div style="white-space: pre-wrap; word-break: break-all; margin-bottom: 5px; border-bottom: 1px solid rgba(255,255,255,0.1);">${log}</div>`;
        });
        html += '</div>';
        html += '</div>';
      }
      
      debugContent.innerHTML = html;
    }
    
    // Copy debug info to clipboard - simplified for mobile
    window.copyDebugInfo = function() {
      const debugText = `=== MOBILE DEBUG INFO ===
Platform: ${JSON.stringify(debugInfo.platform, null, 2)}
WebGL: ${JSON.stringify(debugInfo.webgl, null, 2)}
Textures Found: ${debugInfo.textures.length}
Textures: ${JSON.stringify(debugInfo.textures, null, 2)}
Performance: ${JSON.stringify(debugInfo.performance, null, 2)}
Errors: ${JSON.stringify(debugInfo.errors, null, 2)}

=== TEXTURE LOGS ===
${debugInfo.logs.filter(log => log.includes('Texture') || log.includes('GLB') || log.includes('MOBILE')).join('\n')}
`;
      
      // Simple fallback method that works on mobile
      const textarea = document.createElement('textarea');
      textarea.value = debugText;
      textarea.style.position = 'fixed';
      textarea.style.top = '50%';
      textarea.style.left = '50%';
      textarea.style.transform = 'translate(-50%, -50%)';
      textarea.style.width = '80%';
      textarea.style.height = '200px';
      textarea.style.zIndex = '99999';
      textarea.style.background = 'white';
      textarea.style.color = 'black';
      textarea.style.border = '2px solid blue';
      textarea.style.padding = '10px';
      textarea.style.fontSize = '12px';
      
      document.body.appendChild(textarea);
      
      // Select the text
      textarea.select();
      textarea.setSelectionRange(0, 99999); // For mobile devices
      
      // Add instructions
      const instructions = document.createElement('div');
      instructions.innerHTML = 'Text selected! Now:<br>1. Long press on selected text<br>2. Choose "Copy"<br>3. Tap outside to close';
      instructions.style.position = 'fixed';
      instructions.style.top = '30%';
      instructions.style.left = '50%';
      instructions.style.transform = 'translateX(-50%)';
      instructions.style.background = 'yellow';
      instructions.style.color = 'black';
      instructions.style.padding = '10px';
      instructions.style.zIndex = '99999';
      instructions.style.borderRadius = '5px';
      instructions.style.fontSize = '14px';
      instructions.style.fontWeight = 'bold';
      instructions.style.textAlign = 'center';
      
      document.body.appendChild(instructions);
      
      // Remove on click outside
      setTimeout(() => {
        document.addEventListener('click', function removeTextarea(e) {
          if (e.target !== textarea) {
            document.body.removeChild(textarea);
            document.body.removeChild(instructions);
            document.removeEventListener('click', removeTextarea);
          }
        });
      }, 100);
    }
    
    function toggleDebugPanel() {
      const panel = document.getElementById('mobile-debug-panel');
      if (panel) {
        panel.classList.toggle('visible');
        if (panel.classList.contains('visible')) {
          updateDebugPanel();
        }
      }
    }
    
    // Make toggleDebugPanel globally accessible
    window.toggleDebugPanel = toggleDebugPanel;
    
    // Setup debug button click handler
    function setupDebugButton() {
      const debugBtn = document.getElementById('debug-toggle-btn');
      if (debugBtn) {
        // Remove any existing inline onclick
        debugBtn.onclick = null;
        
        // Add proper event listeners
        debugBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          toggleDebugPanel();
        });
        
        // Add touch handler for better mobile support
        debugBtn.addEventListener('touchend', (e) => {
          e.preventDefault();
          e.stopPropagation();
          toggleDebugPanel();
        }, { passive: false });
      }
    }
    
    // Show debug button on mobile
    if (isMobileEarly) {
      // Show button immediately, don't wait for DOMContentLoaded
      setTimeout(() => {
        const debugBtn = document.getElementById('debug-toggle-btn');
        if (debugBtn) {
          debugBtn.style.display = 'block';
          setupDebugButton();
          console.log('📱 Debug button shown and configured');
        }
        document.body.classList.add('is-mobile');
        
        // Add console logging for debugging
        console.log('📱 Mobile Debug Initialized');
        console.log('Platform:', typeof mobileSettings !== 'undefined' ? mobileSettings : 'Settings not ready');
        
        // Panel starts closed - do not auto-show
        const panel = document.getElementById('mobile-debug-panel');
        if (panel) {
          // Ensure panel starts hidden
          panel.classList.remove('visible');
          updateDebugPanel();
          console.log('📱 Debug panel initialized (closed)');
        }
      }, 100);
    }
    
    // Comprehensive WebGL capability detection
    function getMobileTextureSettings() {
      const testRenderer = new THREE.WebGLRenderer();
      const gl = testRenderer.getContext();
      
      // Get all WebGL capabilities
      const capabilities = {
        maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
        maxTextureUnits: gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),
        maxVertexTextureUnits: gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
        maxAnisotropy: testRenderer.capabilities.getMaxAnisotropy(),
        precision: testRenderer.capabilities.precision,
        maxVertexUniforms: gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS),
        maxFragmentUniforms: gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS),
        webglVersion: gl.getParameter(gl.VERSION),
        shadingLanguageVersion: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
        vendor: gl.getParameter(gl.VENDOR),
        renderer: gl.getParameter(gl.RENDERER),
        // Memory estimation (not directly available but useful indicators)
        maxViewportDims: gl.getParameter(gl.MAX_VIEWPORT_DIMS),
        maxRenderBufferSize: gl.getParameter(gl.MAX_RENDERBUFFER_SIZE),
        // Check for important extensions
        hasCompressedTextures: gl.getExtension('WEBGL_compressed_texture_s3tc') !== null,
        hasFloatTextures: gl.getExtension('OES_texture_float') !== null,
        hasDepthTexture: gl.getExtension('WEBGL_depth_texture') !== null
      };
      
      testRenderer.dispose();
      
      // Detect iOS specifically as it has unique texture issues
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
      const isAndroid = /Android/i.test(navigator.userAgent);
      const isMobileSafari = isIOS && /Version\/[\d\.]+.*Safari/.test(navigator.userAgent);
      
      console.log('📱 WebGL Capabilities Detection:', capabilities);
      console.log('📱 Mobile Platform:', {
        isIOS,
        isAndroid,
        isMobileSafari,
        userAgent: navigator.userAgent
      });
      
      // Log warnings for potential issues
      if (capabilities.maxTextureSize < 2048) {
        console.warn('⚠️ Low max texture size:', capabilities.maxTextureSize);
      }
      if (capabilities.maxTextureUnits < 8) {
        console.warn('⚠️ Low texture units:', capabilities.maxTextureUnits);
      }
      
      return {
        ...capabilities,
        isIOS,
        isAndroid,
        isMobileSafari
      };
    }
    
    const mobileSettings = getMobileTextureSettings();
    
    // Populate debug info with platform and WebGL data
    if (isMobileEarly) {
      debugInfo.platform = {
        'Device': mobileSettings.isIOS ? 'iOS' : (mobileSettings.isAndroid ? 'Android' : 'Other'),
        'Browser': mobileSettings.isMobileSafari ? 'Safari' : 'Other',
        'Screen': `${window.screen.width}x${window.screen.height}`,
        'Pixel Ratio': window.devicePixelRatio
      };
      
      debugInfo.webgl = {
        'Max Texture': mobileSettings.maxTextureSize,
        'Texture Units': mobileSettings.maxTextureUnits,
        'Anisotropy': mobileSettings.maxAnisotropy,
        'Precision': mobileSettings.precision,
        'WebGL Version': mobileSettings.webglVersion ? mobileSettings.webglVersion.substring(0, 20) : 'Unknown',
        'Renderer': mobileSettings.renderer ? mobileSettings.renderer.substring(0, 30) : 'Unknown'
      };
      
      updateDebugPanel();
    }
    
    // Helper to get optimal canvas size for mobile
    function getOptimalCanvasSize(desiredWidth, desiredHeight, isMobile) {
      if (!isMobile) {
        // Desktop: use square power-of-2 dimensions  
        return { width: 2048, height: 2048 };
      }
      
      // Mobile: use smaller square power-of-2 dimensions
      const maxSize = Math.min(mobileSettings.maxTextureSize, 1024);
      
      // Square power-of-2 dimensions for maximum compatibility
      let size = 512;  // Default mobile size
      
      if (maxSize >= 1024) {
        size = 1024;  // Larger devices can handle 1024x1024
      } else if (maxSize < 512) {
        size = 256;  // Very low-end devices
      }
      
      console.log(`📐 Optimal canvas size for mobile: ${size}x${size} (square)`);
      return { width: size, height: size };
    }
    
    // REMOVED: configureMobileTexture function
    // Documentation shows someone got it working without any special texture handling
    // The issue was likely caused by double color space conversion or over-configuration
    
    // Create texture loader with CORS support for future use
    const textureLoader = new THREE.TextureLoader();
    textureLoader.crossOrigin = 'anonymous';  // Enable CORS for external textures

    // Scene setup
    const scene = new THREE.Scene();
    // Test if we can see ANY background on mobile - use bright color for debugging
    if (isMobileEarly) {
      scene.background = new THREE.Color(0x222222); // Darker gray for mobile visibility test
    } else {
      scene.background = new THREE.Color(0x000011); // Original dark blue for desktop
    }

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    // Create user object/group that the camera is attached to
    const userObject = new THREE.Group();
    userObject.add(camera);
    scene.add(userObject);
    
    // Create local user avatar visible to the current user
    const localAvatarGeometry = new THREE.SphereGeometry(0.15, 8, 6);
    const localAvatarMaterial = new THREE.MeshBasicMaterial({ 
      color: 0x00ff00, // Green color for current user
      transparent: true,
      opacity: 0.6
    });
    const localAvatar = new THREE.Mesh(localAvatarGeometry, localAvatarMaterial);
    localAvatar.position.set(0, -0.3, -0.8); // Below and in front of camera
    userObject.add(localAvatar);
    const isIOSNew = /iPhone|iPad/.test(navigator.userAgent) && parseFloat(navigator.userAgent.match(/OS (\d+)/)?.[1] || '0') >= 17;
    
    // Test WebGL 2 support first, then fall back to WebGL 1
    let webglTestCanvas = document.createElement('canvas');
    let testGL = null;
    let webglSupported = false;
    let webgl2Supported = false;
    let highpSupported = false;
    
    try {
      // Try WebGL 2 first
      testGL = webglTestCanvas.getContext('webgl2');
      if (testGL) {
        webgl2Supported = true;
        webglSupported = true;
        console.log('✅ WebGL 2 supported!');
      } else {
        // Fall back to WebGL 1
        testGL = webglTestCanvas.getContext('webgl') || webglTestCanvas.getContext('experimental-webgl');
        if (testGL) {
          webglSupported = true;
          console.log('⚠️ WebGL 1 supported (WebGL 2 not available)');
        }
      }
      
      if (testGL) {
        // Test shader precision support
        const fragmentShaderPrecision = testGL.getShaderPrecisionFormat(testGL.FRAGMENT_SHADER, testGL.HIGH_FLOAT);
        highpSupported = fragmentShaderPrecision && fragmentShaderPrecision.precision > 0;
        console.log('WebGL version:', webgl2Supported ? '2.0' : '1.0', 'Highp supported:', highpSupported);
      }
    } catch (e) {
      console.error('WebGL context creation failed:', e);
    } finally {
      if (testGL) {
        // Clean up test context to avoid context limit issues
        const loseContextExt = testGL.getExtension('WEBGL_lose_context');
        if (loseContextExt) loseContextExt.loseContext();
      }
      webglTestCanvas = null;
      testGL = null;
    }
    
    if (!webglSupported) {
      document.body.innerHTML = '<div style="color: white; text-align: center; margin-top: 50px;">WebGL not supported on this device</div>';
      throw new Error('WebGL not supported');
    }
    
    // Create renderer with WebGL 2 if available (better texture support)
    const rendererParams = {
      antialias: false, // Disable on all devices to avoid mobile issues
      alpha: false, // CRITICAL: Research shows alpha: true causes mobile white screens
      powerPreference: "high-performance", // Research shows this helps with multiple GPUs
      preserveDrawingBuffer: true, // Required for some mobile browsers
      failIfMajorPerformanceCaveat: false,
      stencil: false, // Disable stencil buffer to save memory
      depth: true,
      logarithmicDepthBuffer: false // Can cause issues on some mobile GPUs
    };
    
    // Create the renderer (WebGL 2 will be used automatically if available)
    const renderer = new THREE.WebGLRenderer(rendererParams);
    
    // Log which WebGL version is being used
    const glContext = renderer.getContext();
    const isWebGL2 = glContext instanceof WebGL2RenderingContext;
    console.log(`🎮 Using WebGL ${isWebGL2 ? '2' : '1'} for rendering`);
    
    // Conservative sizing for mobile
    const maxSize = isMobileEarly ? 1024 : 2048;
    const actualWidth = Math.min(window.innerWidth, maxSize);
    const actualHeight = Math.min(window.innerHeight, maxSize);
    
    renderer.setSize(actualWidth, actualHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Research-backed pixel ratio handling
    console.log(`🖥️ Renderer pixel ratio: ${Math.min(window.devicePixelRatio, 2)} (device: ${window.devicePixelRatio})`);
    
    // Essential renderer settings
    // Set outputColorSpace for ALL devices - required for GLB textures to display correctly
    // The issue was material modification, not color space
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.NoToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.sortObjects = false; // Disable sorting for performance
    renderer.shadowMap.enabled = false; // Always disable shadows
    
    // CRITICAL: Set clear color only if no scene background (research-backed fix)
    if (!scene.background) {
      renderer.setClearColor(0x000000, 1); // Black background, full opacity
    }
    
    console.log('Mobile-optimized renderer created');
    
    // Shadow map setup will be handled in lighting section based on device type
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // Add context loss/restore handling before appending to DOM
    const canvas = renderer.domElement;
    canvas.addEventListener('webglcontextlost', function(event) {
      event.preventDefault();
      console.warn('WebGL context lost - attempting recovery');
      // Stop animation loop
      if (window.animationId) {
        cancelAnimationFrame(window.animationId);
      }
    }, false);
    
    canvas.addEventListener('webglcontextrestored', function(event) {
      console.log('WebGL context restored - reinitializing');
      // Force page reload on context restore for now (simplest recovery)
      window.location.reload();
    }, false);
    
    // Set canvas style for mobile compatibility (research-backed)
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    canvas.style.touchAction = 'none'; // CRITICAL: Prevents scrolling on touch (research-backed)
    
    document.getElementById('scene-container').appendChild(canvas);

    // Detect mobile devices
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    console.log('Mobile device detected:', isMobile);
    
    // Check WebGL capabilities and renderer info
    const gl = renderer.getContext();
    console.log('=== DEVICE INFO ===');
    console.log('User Agent:', navigator.userAgent);
    console.log('Mobile detected:', isMobile);
    console.log('Device pixel ratio:', window.devicePixelRatio);
    console.log('=== WEBGL INFO ===');
    console.log('WebGL version:', gl.getParameter(gl.VERSION));
    console.log('WebGL vendor:', gl.getParameter(gl.VENDOR));
    console.log('WebGL renderer:', gl.getParameter(gl.RENDERER));
    console.log('Max texture size:', gl.getParameter(gl.MAX_TEXTURE_SIZE));
    console.log('WebGL context valid:', !gl.isContextLost());
    console.log('Renderer info:', renderer.info);
    
    // CRITICAL: Research-backed context debugging
    console.log('=== RENDERER DEBUG ===');
    console.log('Renderer context:', !!renderer.getContext());
    console.log('Canvas size:', renderer.domElement.width, 'x', renderer.domElement.height);
    console.log('Canvas style size:', renderer.domElement.style.width, 'x', renderer.domElement.style.height);
    console.log('Pixel ratio:', renderer.getPixelRatio());
    // Skip getClearColor() as it's causing errors
    console.log('Clear color: (skipped due to error)');
    console.log('=== SCENE INFO ===');
    console.log('Scene background:', scene.background);

    // Post-processing setup for subtle bloom effect
    let composer = null;
    
    // Enable bloom for both desktop and mobile
    composer = new EffectComposer(renderer);
    
    // Basic render pass
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);
    
    // Bloom pass - optimized settings for mobile vs desktop
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      isMobile ? 0.12 : 0.15,   // strength (slightly less on mobile for performance)
      isMobile ? 0.3 : 0.4,      // radius (smaller on mobile)
      isMobile ? 0.96 : 0.95     // threshold (higher on mobile = less bloom)
    );
    
    // Mobile-optimized bloom resolution
    if (isMobile) {
      bloomPass.resolution.set(window.innerWidth * 0.5, window.innerHeight * 0.5);
    }
    
    composer.addPass(bloomPass);
    
    // Output pass for proper color space
    const outputPass = new OutputPass();
    composer.addPass(outputPass);
    
    console.log(`Bloom post-processing enabled for ${isMobile ? 'mobile' : 'desktop'}`);

    // Ultra-simple lighting for maximum mobile compatibility
    const ambientLight = new THREE.AmbientLight(0xffffff, isMobile ? 2.0 : 0.3);
    scene.add(ambientLight);

    // Minimal directional light for mobile
    const directionalLight = new THREE.DirectionalLight(0xffffff, isMobile ? 0.2 : 0.8);
    directionalLight.position.set(5, 5, 5);
    
    // Disable shadows on mobile for better performance and compatibility
    if (!isMobile) {
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      renderer.shadowMap.enabled = true;
    } else {
      renderer.shadowMap.enabled = false;
      console.log('Shadows disabled for mobile compatibility');
    }
    
    scene.add(directionalLight);
    
    console.log('=== LIGHTING INFO ===');
    console.log('Ambient light intensity:', ambientLight.intensity);
    console.log('Directional light intensity:', directionalLight.intensity);
    console.log('Shadows enabled:', renderer.shadowMap.enabled);

    // Initialize object management variables first
    let sceneObjects = [];
    let selectedObject = null;
    let isScreenVisible = true;
    
    // Selection system
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let selectedOutline = null;


    // Add floor - use basic material on mobile for better compatibility
    const floorGeometry = new THREE.PlaneGeometry(20, 20);
    const floorMaterial = isMobile 
      ? new THREE.MeshBasicMaterial({ color: 0x333333 })
      : new THREE.MeshLambertMaterial({ color: 0x333333 });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -3;
    if (!isMobile) floor.receiveShadow = true;
    scene.add(floor);
    



    // Create canvas texture for screen content
    function createScreenTexture() {
      const canvas = document.createElement('canvas');
      // Use standard HD dimensions for all devices
      canvas.width = 1920;
      canvas.height = 1080;
      
      console.log(`📐 Large screen canvas: ${canvas.width}x${canvas.height} (mobile: ${isMobile})`)
      const ctx = canvas.getContext('2d');
      
      // Fill background
      ctx.fillStyle = '#001122';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw text content
      ctx.fillStyle = '#00ff00';
      const scale = canvas.width / 1920; // Scale relative to desktop size
      
      ctx.font = `bold ${Math.floor(72 * scale)}px Arial`;
      ctx.textAlign = 'center';
      ctx.fillText('LARGE DISPLAY SCREEN', canvas.width/2, canvas.height/2 - Math.floor(80 * scale));
      ctx.font = `bold ${Math.floor(48 * scale)}px Arial`;
      ctx.fillText('Ready for Screen Sharing or Video', canvas.width/2, canvas.height/2 + Math.floor(10 * scale));
      ctx.font = `${Math.floor(32 * scale)}px Arial`;
      ctx.fillText('Use controls to share desktop or load video', canvas.width/2, canvas.height/2 + Math.floor(80 * scale));
      
      const texture = new THREE.CanvasTexture(canvas);
      
      // Use same settings for all devices - no special mobile handling
      texture.flipY = false;
      texture.wrapS = THREE.RepeatWrapping;
      texture.repeat.x = -1;
      texture.needsUpdate = true;
      texture.offset.x = 1;
      
      return { texture: texture, canvas: canvas };
    }

    // Load the room model and setup SHARESCREEN object
    let largeScreen = null;
    let currentRoomModel = null; // Track the current room model for easy removal
    
    // Helper function to setup room model after loading
    function setupRoomModel(roomModel) {
      roomModel.name = 'RoomModel'; // Ensure name is set for removal
      roomModel.position.set(0, 0, 0);
      roomModel.scale.set(1, 1, 1);
      
      // Setup shadows and find screen object
      roomModel.traverse((child) => {
        if (child.isMesh) {
          if (!isMobile) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
          
          // Check for screen object
          if (child.name === 'SHARESCREEN' || 
              child.name?.toLowerCase().includes('screen')) {
            console.log('Found screen object:', child.name);
            setupScreenObject(child);
          }
        }
      });
      
      scene.add(roomModel);
      currentRoomModel = roomModel; // Track for easy removal
      console.log('Room model setup complete');
      
      // Mark room as loaded and check if we should hide loading
      if (window.loadingStates) {
        window.loadingStates.roomLoaded = true;
        window.checkLoadingComplete();
      } else {
        // Fallback if loading states not initialized
        hideLoadingAnimation();
      }
    }
    
    // Hide loading animation
    function hideLoadingAnimation() {
      const loadingContainer = document.getElementById('loading-container');
      if (loadingContainer && loadingContainer.classList.contains('active')) {
        // Add a slight delay for smooth transition
        setTimeout(() => {
          loadingContainer.classList.remove('active');
        }, 500);
      }
    }
    
    // Setup screen object for video/screen sharing
    function setupScreenObject(screenMesh) {
      const screenTexture = createScreenTexture();
      largeScreen = screenTexture;
      
      if (screenMesh.material) {
        const materials = Array.isArray(screenMesh.material) ? 
                         screenMesh.material : [screenMesh.material];
        
        materials.forEach(material => {
          material.map = screenTexture.texture;
          material.emissive = new THREE.Color(0x222222);
          material.emissiveIntensity = 0.2;
          material.needsUpdate = true;
        });
      }
      
      console.log('Screen object configured');
    }
    
    // Create space environment with aurora, nebula, and particles
    function createSpaceEnvironment(config) {
      // Set space background
      scene.background = new THREE.Color(config.backgroundColor || 0x000000);
      
      // Create starfield
      if (config.starfield) {
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 0.7,
          transparent: true
        });
        
        const starsVertices = [];
        for (let i = 0; i < 10000; i++) {
          const x = (Math.random() - 0.5) * 2000;
          const y = (Math.random() - 0.5) * 2000;
          const z = (Math.random() - 0.5) * 2000;
          starsVertices.push(x, y, z);
        }
        
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
        const starField = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(starField);
      }
      
      // Create aurora effect
      if (config.aurora) {
        const auroraGeometry = new THREE.PlaneGeometry(200, 100, 100, 50);
        const auroraUniforms = {
          time: { value: 0 },
          intensity: { value: 0.5 },
          color: { value: new THREE.Color(0x00ff88) }
        };
        
        const auroraMaterial = new THREE.ShaderMaterial({
          uniforms: auroraUniforms,
          vertexShader: `
            uniform float time;
            uniform float intensity;
            varying vec2 vUv;
            varying float vWave;
            
            void main() {
              vUv = uv;
              vec3 pos = position;
              float wave = sin(position.x * 0.1 + time) * cos(position.y * 0.1 + time * 0.5) * 5.0 * intensity;
              pos.z += wave;
              vWave = wave;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
          `,
          fragmentShader: `
            uniform vec3 color;
            uniform float intensity;
            uniform float time;
            varying vec2 vUv;
            varying float vWave;
            
            void main() {
              float alpha = smoothstep(0.0, 1.0, vUv.y) * intensity;
              alpha *= (sin(vUv.x * 10.0 + time) * 0.5 + 0.5) * 0.3 + 0.7;
              vec3 finalColor = color + vec3(vWave * 0.1);
              gl_FragColor = vec4(finalColor, alpha * 0.6);
            }
          `,
          transparent: true,
          side: THREE.DoubleSide,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });
        
        const aurora = new THREE.Mesh(auroraGeometry, auroraMaterial);
        aurora.position.y = 50;
        aurora.rotation.x = -Math.PI / 4;
        scene.add(aurora);
        
        // Animate aurora in render loop
        window.auroraUniforms = auroraUniforms;
      }
      
      // Create nebula particles
      if (config.nebula) {
        const nebulaGeometry = new THREE.BufferGeometry();
        const nebulaCount = 2000;
        const positions = new Float32Array(nebulaCount * 3);
        const colors = new Float32Array(nebulaCount * 3);
        const sizes = new Float32Array(nebulaCount);
        
        for (let i = 0; i < nebulaCount; i++) {
          positions[i * 3] = (Math.random() - 0.5) * 300;
          positions[i * 3 + 1] = (Math.random() - 0.5) * 200;
          positions[i * 3 + 2] = (Math.random() - 0.5) * 300;
          
          const color = new THREE.Color(0xff00ff);
          colors[i * 3] = color.r;
          colors[i * 3 + 1] = color.g;
          colors[i * 3 + 2] = color.b;
          
          sizes[i] = Math.random() * 5 + 2;
        }
        
        nebulaGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        nebulaGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        nebulaGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        
        const nebulaMaterial = new THREE.PointsMaterial({
          size: 3,
          vertexColors: true,
          transparent: true,
          opacity: 0.6,
          blending: THREE.AdditiveBlending
        });
        
        const nebula = new THREE.Points(nebulaGeometry, nebulaMaterial);
        scene.add(nebula);
        window.nebula = nebula;
      }
      
      // Create floating light particles
      if (config.particles) {
        const particleCount = 500;
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        const particleVelocities = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount; i++) {
          particlePositions[i * 3] = (Math.random() - 0.5) * 100;
          particlePositions[i * 3 + 1] = (Math.random() - 0.5) * 100;
          particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 100;
          
          particleVelocities[i * 3] = (Math.random() - 0.5) * 0.2;
          particleVelocities[i * 3 + 1] = (Math.random() - 0.5) * 0.2;
          particleVelocities[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
        }
        
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        
        const particleMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 1,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending
        });
        
        const lightParticles = new THREE.Points(particleGeometry, particleMaterial);
        lightParticles.userData.velocities = particleVelocities;
        scene.add(lightParticles);
        window.lightParticles = lightParticles;
      }
      
      // No floor - pure space environment
      
      // Adjust lighting for space
      scene.children.forEach(child => {
        if (child.type === 'AmbientLight') {
          child.intensity = 0.3;
        }
        if (child.type === 'DirectionalLight') {
          child.intensity = 0.6;
        }
      });
      
      console.log('Space environment created');
    }
    
    // Show processing status UI
    function showProcessingStatus(message) {
      let statusDiv = document.getElementById('glb-processing-status');
      if (!statusDiv) {
        statusDiv = document.createElement('div');
        statusDiv.id = 'glb-processing-status';
        statusDiv.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(255, 255, 255, 0.1);
          backdrop-filter: blur(10px);
          border: 1px solid rgba(255, 255, 255, 0.2);
          border-radius: 16px;
          padding: 20px 30px;
          color: white;
          font-size: 14px;
          z-index: 10000;
          box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        `;
        document.body.appendChild(statusDiv);
      }
      statusDiv.textContent = message;
      statusDiv.style.display = 'block';
    }
    
    function updateProcessingStatus(message) {
      const statusDiv = document.getElementById('glb-processing-status');
      if (statusDiv) {
        statusDiv.textContent = message;
      }
    }
    
    function hideProcessingStatus() {
      const statusDiv = document.getElementById('glb-processing-status');
      if (statusDiv) {
        statusDiv.style.display = 'none';
      }
    }
    
    async function loadRoomModel() {
      // Get current space configuration
      const spaceConfig = getCurrentSpaceConfig();
      console.log('=== LOADING SPACE ===');
      console.log('Space ID:', spaceConfig.id);
      console.log('Space Name:', spaceConfig.name);
      
      // Debug mobile detection
      console.log('=== MOBILE DETECTION DEBUG ===');
      console.log('isMobile:', isMobile);
      console.log('isMobileEarly:', isMobileEarly);
      console.log('User Agent:', navigator.userAgent);
      
      // isRealIOS is already defined globally at the top
      console.log('Is Real iOS device:', isRealIOS);
      
      // Check if we have a processed room model available
      const processedRoom = glbProcessor.processedModels.get('WEBROOM1');
      
      if (processedRoom && spaceConfig.id === 'default') {
        // Use pre-processed model for default space only
        console.log('Using pre-processed room model');
        const model = glbProcessor.applyProcessedModel(scene, processedRoom, isMobile || isRealIOS);
        setupRoomModel(model);
        return;
      }
      
      // Check if this is a space environment (no room model)
      if (spaceConfig.environment && spaceConfig.environment.type === 'space') {
        console.log('Creating space environment...');
        createSpaceEnvironment(spaceConfig.environment);
        hideLoadingScreen();
        return;
      }
      
      // Use space-specific model paths
      const shouldUseMobileGLTF = isMobile || isRealIOS;
      const modelPath = shouldUseMobileGLTF 
        ? spaceConfig.roomModel.mobile  // Mobile model from config
        : spaceConfig.roomModel.desktop; // Desktop model from config
      
      // Check if model path is null (for pure environment spaces)
      if (!modelPath) {
        console.log('No room model specified, skipping model load');
        hideLoadingScreen();
        return;
      }
      
      console.log(`Loading ${shouldUseMobileGLTF ? 'mobile GLTF (external JPG textures)' : 'desktop GLB (embedded WebP textures)'} room model...`);
      
      // Test if we can load textures at all on mobile
      if (shouldUseMobileGLTF) {
        console.log('🔍 Testing texture loading capability...');
        const testTextureLoader = new THREE.TextureLoader();
        
        // Try to load one texture file directly
        const testTexturePath = './models/unpacked-mobile/couchbake.jpg';
        console.log('Attempting to load test texture:', testTexturePath);
        
        testTextureLoader.load(
          testTexturePath,
          (texture) => {
            console.log('✅ TEST TEXTURE LOADED:', texture);
            console.log('Test texture size:', texture.image.width, 'x', texture.image.height);
            updateDebugPanel(`Test texture OK: ${texture.image.width}x${texture.image.height}`);
          },
          (progress) => {
            console.log('Test texture loading progress:', progress);
          },
          (error) => {
            console.error('❌ TEST TEXTURE FAILED:', error);
            updateDebugPanel('Test texture FAILED');
          }
        );
      }
      
      // BEST PRACTICE: Let GLTFLoader handle everything automatically
      // GLB files embed textures directly, and GLTFLoader handles them properly
      console.log('Starting GLTF loader...');
      loader.load(
        modelPath,
        function (gltf) {
          console.log('✅ GLTF/GLB model loaded successfully from:', modelPath);
          updateDebugPanel('Model loaded');
          
          // Add extensive logging for mobile debugging
          if (isMobile || isRealIOS) {
            console.log('📱 === MOBILE TEXTURE FIX ===');
            console.log('Model loaded, now manually applying textures...');
            
            // Since GLTF isn't linking textures properly, manually load and apply them
            const textureLoader = new THREE.TextureLoader();
            
            // Different texture maps for different spaces
            let textureMap = {};
            
            if (spaceConfig.id === 'white') {
              // White room texture mapping
              textureMap = {
                'floorbake.jpg': ['floor', 'ground'],
                'floor.jpg': ['floor', 'ground'],
                'ceilig.jpg': ['ceiling', 'roof'],
                'fb-walld.jpg': ['wall', 'front', 'back'],
                'lr-wall.jpg': ['wall', 'left', 'right'],
                'posters1.jpg': ['poster', 'picture']
              };
            } else {
              // Default room texture mapping
              textureMap = {
                'couchbake.jpg': ['Back_low_lambert1_0'],  // Exact couch mesh name
                'floorbake.jpg': ['floor', 'ground'],
                'ceiling.jpg': ['ceiling', 'roof'],
                'FBWALLSBK.jpg': ['wall', 'front', 'back'],
                'LRWALLSBK.jpg': ['wall', 'left', 'right']
              };
            }
            
            // Load and apply each texture
            Object.entries(textureMap).forEach(([filename, meshNames]) => {
              // Dynamic texture path based on space
              const texturePath = spaceConfig.id === 'white' 
                ? `./models/unpacked-white/${filename}`
                : `./models/unpacked-mobile/${filename}`;
              
              textureLoader.load(
                texturePath,
                (texture) => {
                  console.log(`✅ Loaded texture: ${filename}`);
                  texture.colorSpace = THREE.SRGBColorSpace;
                  texture.flipY = false; // GLTF uses flipped Y
                  
                  // Find matching meshes and apply texture
                  gltf.scene.traverse((child) => {
                    if (child.isMesh) {
                      const meshName = child.name || '';
                      const meshNameLower = meshName.toLowerCase();
                      
                      // Skip SHARESCREEN object
                      if (meshNameLower.includes('sharescreen') || meshNameLower.includes('screen')) {
                        return; // Don't modify screen share
                      }
                      
                      // Check if this mesh matches any of the target names
                      const shouldApply = meshNames.some(name => {
                        // Check exact match first, then lowercase partial match
                        return meshName === name || meshNameLower.includes(name.toLowerCase());
                      });
                      
                      if (shouldApply && child.material) {
                        console.log(`  Applying ${filename} to ${child.name}`);
                        child.material.map = texture;
                        child.material.needsUpdate = true;
                      }
                    }
                  });
                },
                undefined,
                (error) => {
                  console.error(`❌ Failed to load ${filename}:`, error);
                }
              );
            });
            
            // Also log all mesh names to debug
            console.log('=== ALL MESH NAMES IN MODEL ===');
            gltf.scene.traverse((child) => {
              if (child.isMesh) {
                console.log(`Mesh: "${child.name}" (${child.material ? child.material.type : 'no material'})`);
              }
            });
            
            // Also apply to any mesh without a texture
            setTimeout(() => {
              console.log('Checking for meshes without textures...');
              let untexturedCount = 0;
              
              gltf.scene.traverse((child) => {
                if (child.isMesh && child.material && !child.material.map) {
                  const meshName = (child.name || '');
                  const meshNameLower = meshName.toLowerCase();
                  
                  // Skip SHARESCREEN object
                  if (meshNameLower.includes('sharescreen') || meshNameLower.includes('screen')) {
                    return; // Don't apply textures to screen
                  }
                  
                  untexturedCount++;
                  console.log(`Mesh without texture: ${child.name}`);
                  
                  // Apply a default texture based on name - check exact names first
                  let defaultTexture = 'floorbake.jpg';
                  
                  if (meshName === 'Back_low_lambert1_0') {
                    defaultTexture = 'couchbake.jpg';  // This is the couch with exact name
                  } else if (meshNameLower.includes('wall')) {
                    defaultTexture = 'FBWALLSBK.jpg';
                  } else if (meshNameLower.includes('ceiling')) {
                    defaultTexture = 'ceiling.jpg';
                  } else if (meshNameLower.includes('couch')) {
                    defaultTexture = 'couchbake.jpg';
                  }
                  
                  textureLoader.load(
                    `./models/unpacked-mobile/${defaultTexture}`,
                    (texture) => {
                      texture.colorSpace = THREE.SRGBColorSpace;
                      texture.flipY = false;
                      child.material.map = texture;
                      child.material.needsUpdate = true;
                      console.log(`Applied default ${defaultTexture} to ${child.name}`);
                    }
                  );
                }
              });
              
              console.log(`Found ${untexturedCount} meshes without textures`);
              updateDebugPanel(`Fixed ${untexturedCount} textures`);
            }, 1000);
          }
          
          const roomModel = gltf.scene;
          roomModel.name = 'RoomModel'; // Set name for later removal
          
          // Just add the model to the scene - GLTFLoader handles textures automatically
          roomModel.position.set(0, 0, 0);
          roomModel.scale.set(1, 1, 1);
          
          // Debug all materials and textures
          console.log('=== MATERIAL/TEXTURE DEBUG ===');
          let meshCount = 0;
          let textureCount = 0;
          
          roomModel.traverse((child) => {
            if (child.isMesh) {
              meshCount++;
              
              if (!isMobile) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
              
              // Process materials - reprocess textures for mobile like Sketchfab/Spatial.io
              if (child.material) {
                const materials = Array.isArray(child.material) ? child.material : [child.material];
                
                materials.forEach((material, idx) => {
                  console.log(`Mesh: ${child.name || 'unnamed'} [Material ${idx}]`);
                  console.log('  Type:', material.type);
                  console.log('  Has map:', !!material.map);
                  
                  // MOBILE: Just log texture info, don't modify anything
                  if (material.map) {
                    textureCount++;
                    
                    if (isMobile) {
                      console.log(`  📱 Texture for ${child.name}:`, {
                        hasImage: !!material.map.image,
                        width: material.map.image?.width || 0,
                        height: material.map.image?.height || 0,
                        type: material.map.image?.constructor.name || 'unknown'
                      });
                    }
                    
                    // Update debug panel
                    if (isMobileEarly) {
                      debugInfo.textures.push({
                        name: child.name || 'unnamed',
                        success: material.map && material.map.image,
                        status: material.map && material.map.image ? 
                          `${material.map.image.width}x${material.map.image.height}` : 'No image'
                      });
                      updateDebugPanel();
                    }
                  } else if (material.map) {
                    textureCount++;
                    console.log('  Desktop texture (no processing)');
                    if (material.map.image) {
                      console.log('    Size:', material.map.image.width, 'x', material.map.image.height);
                    }
                  } else {
                    console.log('  No texture map');
                  }
                  
                  console.log('  Color:', material.color?.getHexString());
                });
              }
            }
          });
          
          console.log(`Summary: ${meshCount} meshes, ${textureCount} textures found`);
        
        scene.add(roomModel);
        currentRoomModel = roomModel; // Track the room model for removal
        
        // Force a render update on ALL mobile devices
        const isAnyMobile = isMobile || /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        
        if (isAnyMobile) {
          console.log('Mobile device detected: Forcing render update...');
          
          // Force renderer to update
          renderer.render(scene, camera);
          
          // Also try forcing material updates after a delay
          setTimeout(() => {
            roomModel.traverse((child) => {
              if (child.isMesh && child.material) {
                const materials = Array.isArray(child.material) ? child.material : [child.material];
                materials.forEach(material => {
                  if (material.map) {
                    material.map.needsUpdate = true;
                  }
                  material.needsUpdate = true;
                });
              }
            });
            console.log('Mobile: Forced material updates');
            renderer.render(scene, camera);
          }, 500);
        }
        
        // Find the SHARESCREEN object
        let shareScreenObject = null;
        console.log('Searching for SHARESCREEN object in model...');
        roomModel.traverse((child) => {
          if (child.name) {
            console.log('Found object:', child.name, 'Type:', child.type, 'isMesh:', child.isMesh);
            if (child.name === 'SHARESCREEN' || child.name === 'SHARESCREEN-HERE' || child.name.toLowerCase().includes('sharescreen')) {
              shareScreenObject = child;
              console.log('✓ Found SHARESCREEN object:', child.name, child);
            }
          }
        });
        
        console.log('SHARESCREEN search complete. Found:', shareScreenObject ? 'YES' : 'NO');
        
        if (shareScreenObject) {
          // Create screen texture
          const screenTexture = createScreenTexture();
          
          // Apply the texture to the SHARESCREEN object
          console.log('Applying texture to SHARESCREEN object...');
          console.log('Material:', shareScreenObject.material);
          console.log('Material type:', shareScreenObject.material ? shareScreenObject.material.type : 'none');
          
          // Create a new material specifically for screen content  
          const screenMaterial = new THREE.MeshBasicMaterial({ 
            map: screenTexture.texture,
            transparent: false,
            side: THREE.DoubleSide
          });
          
          // Ensure texture color space is correct
          screenTexture.texture.colorSpace = THREE.SRGBColorSpace;
          
          shareScreenObject.material = screenMaterial;
          shareScreenObject.material.needsUpdate = true;
          shareScreenObject.visible = true;
          
          console.log('✓ Applied new MeshBasicMaterial with screen texture');
          console.log('Texture size:', screenTexture.canvas.width, 'x', screenTexture.canvas.height);
          
          // Set up largeScreen object to work with existing code
          largeScreen = {
            screen: shareScreenObject,
            texture: screenTexture.texture,
            canvas: screenTexture.canvas
          };
          
          shareScreenObject.userData = {
            name: 'Large Display Screen',
            type: 'display',
            originalPosition: shareScreenObject.position.clone(),
            originalScale: shareScreenObject.scale.clone(), // This now includes the square aspect adjustment
            originalRotation: shareScreenObject.rotation.clone(),
            objectId: 'SHARESCREEN-HERE',  // Fixed ID for server reference
            isSelectable: false  // Mark screen as non-selectable
          };
          
          sceneObjects.push(shareScreenObject);
          console.log('SHARESCREEN object configured successfully');
        } else {
          console.warn('SHARESCREEN object not found in model, creating fallback screen');
          createFallbackScreen();
        }
        
        console.log('Room model loaded successfully');
        
        // Mobile: Just log analysis, don't modify anything
        if (isMobile) {
          console.log('📱 === MOBILE GLB ANALYSIS ===');
          
          // Log what we loaded
          setTimeout(() => {
            let meshCount = 0;
            let textureCount = 0;
            let texturesWithImages = 0;
            
            roomModel.traverse((child) => {
              if (child.isMesh) {
                meshCount++;
                if (child.material) {
                  const materials = Array.isArray(child.material) ? child.material : [child.material];
                  materials.forEach(material => {
                    if (material.map) {
                      textureCount++;
                      if (material.map.image) {
                        texturesWithImages++;
                      }
                    }
                  });
                }
              }
            });
            
            console.log('=== GLB LOAD SUMMARY ===');
            console.log('Meshes:', meshCount);
            console.log('Textures:', textureCount);
            console.log('Textures with images:', texturesWithImages);
            console.log('Model loaded from:', modelPath);
            
            // Update debug info
            debugInfo.performance = {
              'Meshes': meshCount,
              'Textures': textureCount,
              'Images Loaded': texturesWithImages,
              'Model': modelPath.includes('mob') ? 'Mobile GLB' : 'Desktop GLB'
            };
            updateDebugPanel();
          }, 2000);
        }
        },
        function(xhr) {
          // Progress callback - fix Infinity% issue
          if (xhr.total && xhr.total > 0) {
            const percentComplete = (xhr.loaded / xhr.total * 100).toFixed(2);
            console.log('Room loading progress:', percentComplete + '%');
            
            // Update loading animation text with progress
            const loadingText = document.querySelector('.loading-text');
            const loadingSubtext = document.querySelector('.loading-subtext');
            if (loadingText) {
              if (percentComplete < 30) {
                loadingText.textContent = 'Initializing';
                loadingSubtext.textContent = 'Preparing virtual environment...';
              } else if (percentComplete < 60) {
                loadingText.textContent = 'Loading Assets';
                loadingSubtext.textContent = `Loading 3D models... ${Math.round(percentComplete)}%`;
              } else if (percentComplete < 90) {
                loadingText.textContent = 'Building World';
                loadingSubtext.textContent = `Constructing environment... ${Math.round(percentComplete)}%`;
              } else {
                loadingText.textContent = 'Finalizing';
                loadingSubtext.textContent = 'Almost ready...';
              }
            }
            
            // Update debug panel with loading progress
            if (isMobileEarly || isRealIOS) {
              debugInfo.performance['Loading'] = percentComplete + '%';
              updateDebugPanel();
            }
          } else {
            // When total is not available (CORS or chunked transfer)
            console.log('Room loading:', xhr.loaded, 'bytes');
            const loadingSubtext = document.querySelector('.loading-subtext');
            if (loadingSubtext) {
              loadingSubtext.textContent = `Loading assets... ${Math.round(xhr.loaded / 1024)}KB`;
            }
            if (isMobileEarly || isRealIOS) {
              debugInfo.performance['Loading'] = Math.round(xhr.loaded / 1024) + 'KB';
              updateDebugPanel();
            }
          }
        },
        function(error) {
          console.error('❌ An error occurred loading the GLTF/GLB model:', error);
          console.log('Model path was:', modelPath);
          
          if (isMobileEarly || isRealIOS) {
            console.error('Mobile model load error details:', {
              message: error.message,
              type: error.type,
              path: modelPath
            });
            debugInfo.performance['Loading'] = 'ERROR';
            updateDebugPanel();
          }
          
          // Hide loading animation on error
          hideLoadingAnimation();
          
          console.log('Creating fallback screen instead');
          createFallbackScreen();
        }
      );
    }
    
    // Fallback screen creation if GLB fails to load
    function createFallbackScreen() {
      const screenWidth = 16;
      const screenHeight = 9; // 16:9 aspect ratio
      const screenTexture = createScreenTexture();
      
      const screenGeometry = new THREE.PlaneGeometry(screenWidth, screenHeight);
      const screenMaterial = new THREE.MeshBasicMaterial({ 
        map: screenTexture.texture,
        transparent: false,
        side: THREE.DoubleSide  // Ensure visibility from both sides
      });
      
      // Ensure texture is properly configured for mobile
      if (isMobile || mobileSettings.isIOS || mobileSettings.isAndroid) {
        // Mobile devices need specific texture settings
        screenMaterial.map.minFilter = THREE.LinearFilter;
        screenMaterial.map.magFilter = THREE.LinearFilter;
        console.log('📱 Applied mobile-specific screen material settings');
      } else {
        // Desktop can use default settings
        screenTexture.texture.colorSpace = THREE.SRGBColorSpace;
      }
      
      const displayScreen = new THREE.Mesh(screenGeometry, screenMaterial);
      displayScreen.position.set(0, 4.5, -10); // Original Y position
      displayScreen.rotation.y = 0;
      
      scene.add(displayScreen);
      
      largeScreen = {
        screen: displayScreen,
        texture: screenTexture.texture,
        canvas: screenTexture.canvas
      };
      
      displayScreen.userData = {
        name: 'Large Display Screen',
        type: 'display',
        originalPosition: displayScreen.position.clone(),
        originalScale: displayScreen.scale.clone(),
        originalRotation: displayScreen.rotation.clone(),
        objectId: 'SHARESCREEN-HERE',  // Fixed ID for server reference
        isSelectable: false  // Mark screen as non-selectable
      };
      
      sceneObjects.push(displayScreen);
    }
    
    // Screen sharing and video functionality
    let currentStream = null;
    let currentVideo = null;
    
    // User count display and user list management
    function updateUserCount(count) {
      const userCountElement = document.getElementById('user-count');
      if (userCountElement) {
        userCountElement.textContent = `👥 Users: ${count}`;
      }
    }
    
    // Visitor count display (Disabled)
    /*
    function updateVisitorCount(count) {
      const visitorCountElement = document.getElementById('visitor-count-number');
      if (visitorCountElement) {
        // Format number with commas for large numbers
        const formattedCount = count.toLocaleString();
        visitorCountElement.textContent = formattedCount;
      }
    }
    */
    
    // Initialize Cloudflare visitor counter (Disabled)
    /*
    async function initializeCloudflareVisitorCounter() {
      try {
        // Try multiple possible worker URLs
        const WORKER_URLS = [
          'https://visitor-counter.metamike.workers.dev',
          'https://visitor-counter.mikecerqua.workers.dev',
          'https://visitor-counter.threejs-multiuser.workers.dev'
        ];
        
        // Generate or retrieve a unique visitor ID for this browser
        let visitorId = localStorage.getItem('visitorId');
        if (!visitorId) {
          visitorId = 'visitor_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          localStorage.setItem('visitorId', visitorId);
        }
        
        // Try each URL until one works
        let success = false;
        for (const CLOUDFLARE_API of WORKER_URLS) {
          try {
            // Increment the visitor count
            const response = await fetch(`${CLOUDFLARE_API}/increment`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              }
            });
            
            if (response.ok) {
              const data = await response.json();
              if (data.count !== undefined) {
                updateVisitorCount(data.count);
                console.log(`✅ Cloudflare visitor count: ${data.count} from ${CLOUDFLARE_API}`);
                success = true;
                break;
              }
            }
          } catch (err) {
            console.log(`Failed to connect to ${CLOUDFLARE_API}:`, err.message);
          }
        }
        
        if (!success) {
          console.warn('Could not connect to any Cloudflare Worker URL');
          // Use Railway backend as fallback for visitor counting
          useRailwayVisitorCounter();
        }
      } catch (error) {
        console.error('Error connecting to Cloudflare visitor counter:', error);
        // Continue with the app even if visitor counter fails
        useRailwayVisitorCounter();
      }
    }
    */
    
    // Fallback visitor counter using Railway backend (Disabled)
    /*
    async function useRailwayVisitorCounter() {
      try {
        // Use the Railway backend to store visitor count
        if (socket && socket.connected) {
          socket.emit('visitor-increment', { visitorId: localStorage.getItem('visitorId') });
          socket.on('visitor-count', (data) => {
            if (data.count !== undefined) {
              updateVisitorCount(data.count);
              console.log(`✅ Railway visitor count: ${data.count}`);
            }
          });
        }
      } catch (error) {
        console.error('Error with Railway visitor counter:', error);
      }
    }
    */
    
    // Space name display
    function updateSpaceName(spaceName) {
      // You can add space name display if needed
      console.log('Connected to space:', spaceName);
    }

    function updateUserList() {
      console.log('🔧 updateUserList called, myUserId:', myUserId, 'userAvatars size:', userAvatars.size);
      const userListContent = document.getElementById('user-list-content');
      const currentUserElement = document.getElementById('current-user');
      
      if (!userListContent) {
        console.log('❌ userListContent not found');
        return;
      }
      
      // Clear existing user items (except current user)
      const userItems = userListContent.querySelectorAll('.user-item:not(.self)');
      userItems.forEach(item => item.remove());
      
      // Update current user with clickable name
      if (currentUserElement && myUserId) {
        // Find current user data
        let currentUser = userAvatars.get(myUserId);
        if (!currentUser) {
          // This should not happen, but provide fallback
          currentUser = { username: `User${myUserId.substr(0,4)}` };
          userAvatars.set(myUserId, currentUser);
        }
        console.log('🔧 Current user for name editing:', currentUser);
        
        // Clear and recreate current user element
        currentUserElement.innerHTML = '';
        
        const nameSpan = document.createElement('span');
        nameSpan.className = 'editable-name';
        nameSpan.textContent = currentUser.username;
        nameSpan.style.cursor = 'pointer';
        nameSpan.style.textDecoration = 'underline';
        nameSpan.style.color = '#4CAF50';
        nameSpan.title = 'Click to edit your name';
        
        nameSpan.addEventListener('click', (e) => {
          console.log('📝 Name span clicked!', e);
          e.preventDefault();
          e.stopPropagation();
          editUserName();
        });
        
        const youLabel = document.createElement('span');
        youLabel.textContent = ' (You)';
        youLabel.style.color = '#ccc';
        
        currentUserElement.appendChild(nameSpan);
        currentUserElement.appendChild(youLabel);
      }
      
      // Add other users
      userAvatars.forEach((avatar, userId) => {
        if (userId !== myUserId) {
          const userItem = document.createElement('div');
          userItem.className = 'user-item';
          userItem.textContent = avatar.username;
          userListContent.appendChild(userItem);
        }
      });
      
      // Update user count badge
      const userCountBadge = document.getElementById('user-count-badge');
      const totalUsers = userAvatars.size; // This includes all users including the current user
      if (userCountBadge) {
        userCountBadge.textContent = `(${totalUsers})`;
      }
    }

    function editUserName() {
      console.log('🔧 editUserName called, myUserId:', myUserId);
      const currentUserElement = document.getElementById('current-user');
      console.log('🔧 currentUserElement:', currentUserElement);
      if (!currentUserElement || !myUserId) {
        console.log('❌ editUserName: Missing currentUserElement or myUserId');
        return;
      }
      
      // Find current user data
      let currentUser = userAvatars.get(myUserId);
      if (!currentUser) {
        // This should not happen, but provide fallback
        currentUser = { username: `User${myUserId.substr(0,4)}` };
        userAvatars.set(myUserId, currentUser);
      }
      console.log('🔧 editUserName currentUser:', currentUser);
      
      // Create input field
      const input = document.createElement('input');
      input.type = 'text';
      input.value = currentUser.username;
      input.maxLength = 20;
      input.style.cssText = `
        background: rgba(0,0,0,0.8);
        border: 1px solid #4CAF50;
        color: white;
        padding: 2px 5px;
        border-radius: 3px;
        font-size: 12px;
        width: 80px;
      `;
      
      // Replace name span with input
      const nameSpan = currentUserElement.querySelector('.editable-name');
      if (nameSpan) {
        nameSpan.style.display = 'none';
        currentUserElement.insertBefore(input, nameSpan);
        input.focus();
        input.select();
        
        const saveChanges = () => {
          const newName = input.value.trim();
          if (newName && newName !== currentUser.username && newName.length <= 20) {
            // Update locally
            if (userAvatars.has(myUserId)) {
              userAvatars.get(myUserId).username = newName;
            }
            
            // Emit name change to server
            if (socket && socket.connected) {
              socket.emit('user-name-change', { 
                userId: myUserId, 
                newName: newName 
              });
            }
            
            // Update avatar label
            updateAvatarLabel(myUserId, newName);
          }
          
          // Restore normal display
          input.remove();
          nameSpan.style.display = 'inline';
          updateUserList();
        };
        
        const cancelChanges = () => {
          input.remove();
          nameSpan.style.display = 'inline';
        };
        
        input.addEventListener('blur', saveChanges);
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            saveChanges();
          } else if (e.key === 'Escape') {
            e.preventDefault();
            cancelChanges();
          }
        });
      }
    }

    // P2P Main Room functionality
    let socket = null;
    let peers = {};
    const MAIN_ROOM = 'MAIN_SHARED_ROOM';
    let inRoom = false;
    let roomUsers = [];
    let myUserId = null;
    
    // WebRTC P2P for video streaming (separate from server coordination)
    const videoPeers = {};
    let isScreenSharing = false;
    
    // Simple P2P using BroadcastChannel for same-origin communication
    let broadcastChannel = null;
    let activeStreams = new Map(); // Track active streams from other tabs
    
    // Welcome dialog functionality
    let userChosenName = '';
    
    function showWelcomeDialog() {
      const welcomeDialog = document.getElementById('welcome-dialog');
      const welcomeOverlay = document.getElementById('welcome-overlay');
      const welcomeInput = document.getElementById('welcome-input');
      const welcomeButton = document.getElementById('welcome-button');
      
      // Get space configuration and update welcome message
      const spaceConfig = getCurrentSpaceConfig();
      const welcomeTitle = welcomeDialog.querySelector('h2');
      if (welcomeTitle) {
        welcomeTitle.textContent = spaceConfig.name || 'Welcome';
      }
      const welcomeText = welcomeDialog.querySelector('p');
      if (welcomeText) {
        welcomeText.textContent = spaceConfig.welcomeMessage || 'Enter your name to join';
      }
      
      // Apply space theme color to loading animation
      if (spaceConfig.themeColor) {
        document.documentElement.style.setProperty('--theme-color', spaceConfig.themeColor);
      }
      
      // Show the dialog and overlay
      welcomeDialog.style.display = 'block';
      welcomeOverlay.style.display = 'block';
      
      // Focus input (with delay for mobile)
      setTimeout(() => {
        // Only focus on non-touch devices to prevent keyboard popup issues
        if (!('ontouchstart' in window)) {
          welcomeInput.focus();
        }
      }, 100);
      
      // Add explicit touch handling for input field
      welcomeInput.addEventListener('touchstart', (e) => {
        e.stopPropagation(); // Ensure touch events reach the input
      });
      
      // Handle name submission
      function submitName() {
        const name = welcomeInput.value.trim();
        if (name && name.length <= 20) {
          userChosenName = name;
        }
        
        // Hide welcome dialog
        welcomeDialog.style.display = 'none';
        welcomeOverlay.style.display = 'none';
        
        // Show loading animation
        const loadingContainer = document.getElementById('loading-container');
        if (loadingContainer) {
          loadingContainer.classList.add('active');
          
          // Track loading states
          window.loadingStates = {
            roomLoaded: false,
            sceneReady: false,
            timeoutReached: false
          };
          
          // Check if all critical components are loaded
          window.checkLoadingComplete = function() {
            if (window.loadingStates.roomLoaded || window.loadingStates.timeoutReached) {
              hideLoadingAnimation();
            }
          };
          
          // Fallback: Auto-hide loading animation after 5 seconds max
          setTimeout(() => {
            window.loadingStates.timeoutReached = true;
            window.checkLoadingComplete();
          }, 5000);
        }
        
        // Initialize room system with chosen name
        initializeRoomSystem();
      }
      
      // Submit on button click - handle both touch and mouse
      let touchHandled = false;
      
      welcomeButton.addEventListener('touchstart', (e) => {
        touchHandled = true;
        e.preventDefault(); // Prevent mouse events from firing
      });
      
      welcomeButton.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (touchHandled) {
          submitName();
          touchHandled = false;
        }
      });
      
      welcomeButton.addEventListener('click', (e) => {
        // Only handle click if it wasn't a touch event
        if (!touchHandled) {
          submitName();
        }
      });
      
      // Submit on Enter key
      welcomeInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          submitName();
        }
      });
    }
    
    function initializeRoomSystem() {
      console.log('🚀 Initializing WebRTC P2P with Railway Socket.IO signaling...');
      
      // Connect to Railway Socket.IO server (not Netlify which only serves static files)
      const SIGNALING_SERVER = window.location.hostname === 'localhost' 
        ? 'http://localhost:3001'  // Local development
        : 'http://178.156.181.117:3001';  // Hetzner VPS backend
      
      // Cloudflare Worker API for persistent visitor counter
      const VISITOR_COUNTER_API = 'https://visitor-counter.mikecerqua.workers.dev';
      
      try {
        // Use Socket.IO for Railway server
        socket = io(SIGNALING_SERVER, {
          transports: ['websocket', 'polling'],
          reconnection: true,
          reconnectionDelay: 1000,
          reconnectionAttempts: 5,
          autoConnect: true
        });
        
        socket.on('connect', () => {
          console.log('✅ Connected to persistent world server!');
          console.log('🎉 Server-mediated world sharing is now enabled!');
          
          // Send periodic pings to keep connection alive
          if (window.pingInterval) {
            clearInterval(window.pingInterval);
          }
          window.pingInterval = setInterval(() => {
            if (socket.connected) {
              socket.emit('ping');
            }
          }, 25000); // Ping every 25 seconds
          inRoom = true;
          myUserId = socket.id;
          
          // Clear all existing avatars on reconnection
          userAvatars.forEach((avatar, userId) => {
            if (avatar.mesh) {
              scene.remove(avatar.mesh);
            }
          });
          userAvatars.clear();
          customAvatarModels.clear();
          
          // Update user interface
          updateUserList();
          
          // Initialize current user data with chosen name or generate one
          const initialUsername = userChosenName || `User${socket.id.substr(0,4)}`;
          userAvatars.set(myUserId, { username: initialUsername });
          
          // Spawn user avatar in world
          socket.emit('user-spawn', {
            position: { x: 0, y: 0, z: 5 },
            rotation: { x: 0, y: 0, z: 0 },
            username: initialUsername,
            customAvatarUrl: myCustomAvatarUrl
          });
        });
        
        // ===== WORLD STATE SYNCHRONIZATION =====
        socket.on('world-state', (worldData) => {
          console.log('🌍 Received world state:', worldData);
          
          // Apply persistent object positions
          worldData.objects.forEach(([objectId, state]) => {
            updateObjectInScene(objectId, state);
          });
          
          // Load uploaded models from world state
          if (worldData.uploadedModels) {
            worldData.uploadedModels.forEach(([modelId, metadata]) => {
              console.log('🌥️ Loading uploaded model from world state:', metadata.name);
              loadUploadedModelFromWorldState(metadata);
            });
          }
          
          // Spawn existing user avatars
          worldData.users.forEach(([userId, avatar]) => {
            if (userId !== socket.id) {
              console.log(`🧑‍🤝‍🧑 Spawning existing user: ${avatar.username} (${userId})`);
              spawnUserAvatar(userId, avatar);
            }
          });
          
          // Apply shared screen if active
          if (worldData.sharedScreen) {
            handleRemoteScreenShare(worldData.sharedScreen);
          }
          
          // Load chat history
          if (worldData.chatHistory) {
            worldData.chatHistory.forEach(msg => displayChatMessage(msg));
          }
          
          // Update user count from world state
          console.log('🌍 World state users:', worldData.users.length);
          updateUserCount(worldData.users.length);
          updateUserList();
          
          // Skip Railway visitor count - using Cloudflare instead
          // if (worldData.visitorCount !== undefined) {
          //   updateVisitorCount(worldData.visitorCount);
          // }
          
          // Update space name if provided
          if (worldData.spaceName) {
            updateSpaceName(worldData.spaceName);
          }
        });
        
        socket.on('user-joined', (avatar) => {
          // Don't spawn avatar for current user (they have their own local avatar)
          if (avatar.id !== socket.id) {
            spawnUserAvatar(avatar.id, avatar);
          }
          // User count will be updated by server via 'user-count-update' event
          updateUserList();
          
          // If we're currently screen sharing, establish P2P connection with new user
          if (isScreenSharing && currentStream && currentStream.active) {
            console.log(`🔗 Establishing P2P connection with new user ${avatar.id} for screen sharing`);
            connectToPeer(avatar.id, true); // We're the initiator since we're sharing
          }
        });
        
        socket.on('user-left', (data) => {
          removeUserAvatar(data.userId);
          // User count will be updated by server via 'user-count-update' event
          updateUserList();
        });
        
        // ===== PERSISTENT OBJECT INTERACTIONS =====
        socket.on('object-added', (data) => {
          console.log(`📦 New object ${data.objectId} (${data.name}) added by ${data.addedBy}`);
          
          // Handle uploaded models from other users
          if (data.isUploadedModel && data.modelUrl) {
            console.log('🌥️ Loading uploaded model from other user:', data.name);
            
            const loader = new THREE.GLTFLoader();
            
            loader.load(
              data.modelUrl,
              (gltf) => {
                const model = gltf.scene;
                
                // Set unique name for tracking
                model.name = `object_${data.objectId}`;
                
                // Apply position from server
                model.position.copy(data.position);
                model.rotation.copy(data.rotation);
                model.scale.copy(data.scale);
                
                // Configure model for scene
                model.traverse((child) => {
                  if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    
                    // Configure textures for mobile compatibility
                    if (child.material) {
                      const materials = Array.isArray(child.material) ? child.material : [child.material];
                      
                      materials.forEach(material => {
                        const textureProps = ['map', 'normalMap', 'roughnessMap', 'metalnessMap', 'emissiveMap', 'aoMap'];
                        
                        textureProps.forEach(prop => {
                          if (material[prop]) {
                            if (isMobileEarly || mobileSettings.isIOS || mobileSettings.isAndroid) {
                              configureMobileTexture(material[prop]);
                            }
                          }
                        });
                      });
                    }
                  }
                });
                
                // Set up userData with cloud model info
                model.userData = {
                  name: data.name,
                  type: data.type,
                  objectId: data.objectId,
                  originalPosition: model.position.clone(),
                  originalScale: model.scale.clone(),
                  originalRotation: model.rotation.clone(),
                  // Cloud model specific data
                  isUploadedModel: true,
                  modelId: data.modelId,
                  modelUrl: data.modelUrl,
                  uploadedBy: data.uploadedBy
                };
                
                scene.add(model);
                console.log('Cloud model added from other user:', data.name);
              },
              (progress) => {
                // Loading progress
                console.log(`Loading ${data.name}: ${Math.round((progress.loaded / progress.total) * 100)}%`);
              },
              (error) => {
                console.error('Error loading uploaded model from other user:', error);
              }
            );
          }
          // Handle regular objects (non-uploaded models) would go here if needed
        });

        socket.on('object-moved', (data) => {
          console.log(`📦 Object ${data.objectId} moved by ${data.movedBy}`);
          updateObjectInScene(data.objectId, {
            position: data.position,
            rotation: data.rotation,
            scale: data.scale
          });
        });

        socket.on('object-deleted', (data) => {
          console.log(`🗑️ Object ${data.objectId} deleted by ${data.deletedBy}`);
          removeObjectFromScene(data.objectId);
        });
        
        // ===== USER AVATAR EVENTS =====
        socket.on('user-moved', (data) => {
          moveUserAvatar(data.userId, data.position, data.rotation);
        });
        
        socket.on('user-name-changed', (data) => {
          console.log(`📝 User ${data.userId} changed name from "${data.oldName}" to "${data.newName}"`);
          
          // Update local avatar data
          if (userAvatars.has(data.userId)) {
            userAvatars.get(data.userId).username = data.newName;
            updateAvatarLabel(data.userId, data.newName);
          }
          
          // IMPORTANT: If this is the current user, update their stored username
          if (data.userId === myUserId) {
            // Create/update the current user's avatar data
            if (!userAvatars.has(myUserId)) {
              userAvatars.set(myUserId, { username: data.newName });
            } else {
              userAvatars.get(myUserId).username = data.newName;
            }
          }
          
          // Update user list display
          updateUserList();
          
          // Show notification in chat
          const nameChangeMessage = {
            username: 'System',
            message: `${data.oldName} changed their name to ${data.newName}`,
            timestamp: new Date().toISOString(),
            isSystem: true
          };
          displayChatMessage(nameChangeMessage);
        });
        
        socket.on('user-avatar-updated', (data) => {
          console.log(`🎭 User ${data.userId} updated their avatar`);
          
          // Remove old avatar
          removeUserAvatar(data.userId);
          
          // Spawn new avatar with custom model
          const userInfo = userAvatars.get(data.userId);
          if (userInfo) {
            const avatarData = {
              id: data.userId,
              position: data.position || { x: 0, y: 0, z: 0 },
              rotation: data.rotation || { x: 0, y: 0, z: 0 },
              username: userInfo.username,
              customAvatarUrl: data.customAvatarUrl
            };
            
            // Only spawn avatar for other users (not self)
            if (data.userId !== myUserId) {
              spawnUserAvatar(data.userId, avatarData);
            }
          }
        });
        
        // ===== SCREEN SHARING EVENTS =====
        socket.on('screen-share-started', (data) => {
          console.log(`📺 Screen sharing started by ${data.userId}:`, data);
          handleRemoteScreenShare(data);
          
          // Don't initiate P2P connection here - let the screen sharer do it
          console.log(`🔗 Ready to receive P2P connection from ${data.userId} for screen sharing`);
        });
        
        socket.on('screen-share-stopped', (data) => {
          console.log(`📺 Screen sharing stopped by ${data.userId}:`, data);
          clearScreenShare(data.clearObject);
          
          // Close P2P connection
          if (peers[data.userId]) {
            peers[data.userId].destroy();
            delete peers[data.userId];
          }
        });
        
        // ===== WEBRTC P2P SIGNALING =====
        socket.on('webrtc-offer', (data) => {
          console.log(`📨 *** RECEIVED WEBRTC OFFER FROM ${data.from} ***`);
          console.log('📨 Offer data:', data.offer);
          if (!peers[data.from]) {
            console.log(`🔗 Creating peer connection to handle offer from ${data.from}`);
            connectToPeer(data.from, false, data.offer);
          } else {
            console.log(`⚠️ Peer ${data.from} already exists, ignoring offer`);
          }
        });
        
        socket.on('webrtc-answer', (data) => {
          console.log(`📨 *** RECEIVED WEBRTC ANSWER FROM ${data.from} ***`);
          if (peers[data.from]) {
            console.log(`✅ Signaling answer to existing peer ${data.from}`);
            peers[data.from].signal(data.answer);
          } else {
            console.log(`❌ No peer found for answer from ${data.from}`);
          }
        });
        
        socket.on('webrtc-ice-candidate', (data) => {
          console.log(`📨 *** RECEIVED WEBRTC ICE CANDIDATE FROM ${data.from} ***`);
          if (peers[data.from]) {
            peers[data.from].signal(data.candidate);
          } else {
            console.log(`❌ No peer found for ICE candidate from ${data.from}`);
          }
        });
        
        // ===== CHAT SYSTEM =====
        socket.on('chat-message', (message) => {
          displayChatMessage(message);
        });
        
        // ===== VISITOR COUNT UPDATE (disabled - using Cloudflare) =====
        socket.on('visitor-count-update', (data) => {
          // Skip Railway visitor count - using Cloudflare instead
          // if (data.visitorCount !== undefined) {
          //   updateVisitorCount(data.visitorCount);
          // }
        });
        
        // ===== USER COUNT UPDATE =====
        socket.on('user-count-update', (data) => {
          if (data.count !== undefined) {
            console.log('👥 User count update:', data.count);
            updateUserCount(data.count);
          }
        });
        
        socket.on('disconnect', (reason) => {
          console.log(`🔌 Disconnected from signaling server. Reason: ${reason}`);
          inRoom = false;
          
          // Clear ping interval
          if (window.pingInterval) {
            clearInterval(window.pingInterval);
            window.pingInterval = null;
          }
          
          // Clean up all peer connections on disconnect
          Object.keys(peers).forEach(peerId => {
            if (peers[peerId]) {
              console.log(`🧹 Cleaning up peer connection with ${peerId}`);
              peers[peerId].destroy();
              delete peers[peerId];
            }
          });
          
          // Stop screen sharing if active
          if (currentStream) {
            console.log('🛑 Stopping screen share due to disconnect');
            currentStream.getTracks().forEach(track => track.stop());
            currentStream = null;
            isScreenSharing = false;
            document.getElementById('video-element').srcObject = null;
            resetScreenContent();
          }
        });
        
        socket.on('error', (error) => {
          console.error('❌ Signaling server error:', error);
        });
        
      } catch (error) {
        console.error('❌ Failed to initialize P2P:', error);
        console.log('💡 Screen sharing will work locally only');
      }
    }
    
    function sendMessage(message) {
      if (socket && socket.connected) {
        console.log('📤 Sending:', message);
        socket.emit(message.type, message);
      } else {
        console.warn('⚠️ Cannot send message, socket not connected:', message);
      }
    }
    
    // Note: handleSignalingMessage removed - using Socket.IO event handlers directly
    
    
    function connectToPeer(userId, initiator, initialSignal = null) {
      console.log(`🔗 Connecting to peer ${userId}, initiator: ${initiator}, hasStream: ${!!currentStream}`);
      
      // Don't create duplicate connections
      if (peers[userId]) {
        console.log(`⚠️ Peer ${userId} already exists, skipping`);
        return;
      }
      
      console.log(`🔧 Creating SimplePeer for ${userId}: initiator=${initiator}, hasStream=${!!currentStream}`);
      if (currentStream) {
        console.log(`📹 currentStream details: active=${currentStream.active}, tracks=${currentStream.getTracks().length}`);
      }
      
      const peer = new SimplePeer({
        initiator: initiator,
        trickle: false,
        stream: currentStream || undefined // Share current stream if available
      });
      
      peers[userId] = peer;
      
      // Monitor ICE connection state
      if (peer._pc) {
        peer._pc.oniceconnectionstatechange = () => {
          console.log(`🧊 ICE connection state with ${userId}: ${peer._pc.iceConnectionState}`);
          if (peer._pc.iceConnectionState === 'failed') {
            console.error(`❌ ICE connection failed with ${userId}. This might be a firewall/NAT issue.`);
          }
        };
        
        peer._pc.onconnectionstatechange = () => {
          console.log(`🔗 Connection state with ${userId}: ${peer._pc.connectionState}`);
        };
      }
      
      peer.on('signal', (data) => {
        console.log(`📤 *** SENDING WEBRTC SIGNAL TO ${userId} ***`);
        console.log(`📤 Signal type: ${data.type || 'unknown'}`);
        console.log(`📤 Signal data:`, data);
        
        // Use specific events for better reliability
        if (data.type === 'offer') {
          console.log(`📤 Emitting webrtc-offer to ${userId}`);
          socket.emit('webrtc-offer', {
            to: userId,
            offer: data
          });
        } else if (data.type === 'answer') {
          console.log(`📤 Emitting webrtc-answer to ${userId}`);
          socket.emit('webrtc-answer', {
            to: userId,
            answer: data
          });
        } else if (data.candidate) {
          console.log(`📤 Emitting webrtc-ice-candidate to ${userId}`);
          socket.emit('webrtc-ice-candidate', {
            to: userId,
            candidate: data
          });
        } else {
          console.log(`📤 Emitting generic signal to ${userId}`);
          // Fallback to generic signal
          socket.emit('signal', {
            to: userId,
            signal: data
          });
        }
      });
      
      peer.on('stream', (stream) => {
        console.log(`🎥 *** RECEIVED STREAM FROM PEER ${userId} ***`, stream);
        console.log(`🎥 Stream active: ${stream.active}, tracks: ${stream.getTracks().length}`);
        
        stream.getTracks().forEach((track, index) => {
          console.log(`🎵 Track ${index}: kind=${track.kind}, enabled=${track.enabled}, readyState=${track.readyState}`);
        });
        
        // Display received stream on the large screen
        console.log(`🖥️ Calling displaySharedStream...`);
        displaySharedStream(stream);
      });
      
      peer.on('error', (err) => {
        console.error(`❌ Peer error with ${userId}:`, err);
        console.error('Error details:', err.message);
      });
      
      peer.on('close', () => {
        console.log(`🔌 Peer connection closed with ${userId}`);
        delete peers[userId];
      });
      
      peer.on('connect', () => {
        console.log(`🤝 *** PEER CONNECTED: ${userId} ***`);
        console.log(`🤝 P2P connection established successfully with ${userId}`);
        // If we have an active screen share, add it to the new peer
        if (currentStream && currentStream.active) {
          console.log(`📹 Adding existing screen share to newly connected peer ${userId}`);
          try {
            peer.addStream(currentStream);
            console.log(`✅ Successfully added stream to peer ${userId}`);
          } catch (error) {
            console.error(`❌ Failed to add stream to peer ${userId}:`, error);
          }
        }
      });
      
      if (initialSignal) {
        peer.signal(initialSignal);
      }
    }
    
    
    function handleRemoteScreenStop(senderId) {
      const indicator = document.getElementById(`remote-indicator-${senderId}`);
      if (indicator) {
        indicator.remove();
      }
      
      // Reset screen content if no other remote shares
      if (!document.querySelector('[id^="remote-indicator-"]')) {
        resetScreenContent();
      }
    }
    
    function displaySharedStream(stream) {
      console.log(`🖥️ *** DISPLAYING SHARED STREAM ***`);
      console.log(`📺 Stream details: active=${stream.active}, tracks=${stream.getTracks().length}`);
      
      // Remove any existing remote video element
      const existingVideo = document.getElementById('remote-screen-video');
      if (existingVideo) {
        existingVideo.remove();
      }
      
      const videoEl = document.createElement('video');
      videoEl.id = 'remote-screen-video';
      videoEl.srcObject = stream;
      videoEl.autoplay = true;
      videoEl.controls = true;
      videoEl.volume = 1.0; // Full volume
      videoEl.style.display = 'none';
      document.body.appendChild(videoEl);
      
      // Store reference globally to prevent garbage collection
      window.remoteScreenVideo = videoEl;
      
      console.log(`📺 Created video element, autoplay=${videoEl.autoplay}`);
      
      function updateScreenFromPeer() {
        if (videoEl.readyState >= videoEl.HAVE_CURRENT_DATA && largeScreen && largeScreen.canvas) {
          const ctx = largeScreen.canvas.getContext('2d');
          ctx.drawImage(videoEl, 0, 0, largeScreen.canvas.width, largeScreen.canvas.height);
          largeScreen.texture.needsUpdate = true;
          // Only log occasionally to avoid spam
          if (Math.random() < 0.01) {
            console.log(`🎬 Updating screen texture from P2P video (${videoEl.videoWidth}x${videoEl.videoHeight})`);
          }
        } else {
          console.log(`⏸️ Video not ready: readyState=${videoEl.readyState}, hasScreen=${!!largeScreen}`);
        }
        
        if (stream.active) {
          requestAnimationFrame(updateScreenFromPeer);
        } else {
          console.log(`🛑 P2P stream no longer active, stopping updates`);
        }
      }
      
      videoEl.addEventListener('loadeddata', () => {
        console.log(`📹 Video loadeddata event: ${videoEl.videoWidth}x${videoEl.videoHeight}`);
        updateScreenFromPeer();
      });
      
      videoEl.addEventListener('loadedmetadata', () => {
        console.log(`📹 Video metadata loaded: ${videoEl.videoWidth}x${videoEl.videoHeight}`);
      });
      
      videoEl.addEventListener('canplay', () => {
        console.log(`📹 Video can play`);
      });
      
      videoEl.addEventListener('error', (e) => {
        console.error('📹 Video error:', e);
      });
    }
    
    
    
    async function startScreenShare() {
      try {
        const stream = await navigator.mediaDevices.getDisplayMedia({
          video: { width: { ideal: 1920 }, height: { ideal: 1080 } },
          audio: true
        });
        
        currentStream = stream;
        const videoEl = document.getElementById('video-element');
        videoEl.srcObject = stream;
        videoEl.muted = false; // Ensure screen sharing audio is not muted
        videoEl.volume = 1.0; // Set volume to maximum
        videoEl.play();
        
        function updateScreenTexture() {
          if (videoEl.readyState >= videoEl.HAVE_CURRENT_DATA && largeScreen && largeScreen.canvas) {
            const ctx = largeScreen.canvas.getContext('2d');
            ctx.drawImage(videoEl, 0, 0, largeScreen.canvas.width, largeScreen.canvas.height);
            largeScreen.texture.needsUpdate = true;
          }
          
          if (currentStream && currentStream.active) {
            requestAnimationFrame(updateScreenTexture);
          }
        }
        
        videoEl.addEventListener('loadeddata', () => updateScreenTexture());
        stream.getVideoTracks()[0].addEventListener('ended', () => stopScreenShare());
        
        // ===== SERVER-MEDIATED SCREEN SHARING =====
        if (socket && socket.connected) {
          socket.emit('screen-share-start', {
            streamId: stream.id,
            hasVideo: stream.getVideoTracks().length > 0,
            hasAudio: stream.getAudioTracks().length > 0
          });
          console.log('📺 Notified server of screen sharing start');
        }
        
        // ===== WEBRTC P2P FOR ACTUAL VIDEO STREAMING =====
        isScreenSharing = true;
        
        // Connect to existing users for P2P
        console.log(`🔗 Establishing P2P connections with ${userAvatars.size} users for screen sharing`);
        Array.from(userAvatars.keys()).forEach(userId => {
          // Skip self - don't create P2P connection to ourselves
          if (userId === socket.id) {
            console.log(`⏭️ Skipping self connection for ${userId}`);
            return;
          }
          
          console.log(`🔗 Connecting to user ${userId} for screen sharing`);
          
          if (peers[userId]) {
            try {
              peers[userId].addStream(stream);
              console.log(`✅ Added screen stream to existing peer ${userId}`);
            } catch (error) {
              console.log(`⚠️ Recreating connection with ${userId} for screen share`);
              peers[userId].destroy();
              delete peers[userId];
              connectToPeer(userId, true); // Recreate with new stream
            }
          } else {
            // Create new P2P connection with this user
            console.log(`🆕 Creating new P2P connection with ${userId}`);
            connectToPeer(userId, true); // We're the initiator (screen sharer)
          }
        });
        
        // For users who join later, they'll connect via the screen-share-started event
        
        console.log('✅ Screen sharing started successfully!');
        
      } catch (error) {
        console.error('Error starting screen share:', error);
        alert('Screen sharing failed. Please make sure you allow screen access.');
      }
    }
    
    function stopScreenShare() {
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
        currentStream = null;
        document.getElementById('video-element').srcObject = null;
        resetScreenContent();
        // ===== SERVER-MEDIATED SCREEN SHARING STOP =====
        if (socket && socket.connected) {
          socket.emit('screen-share-stop');
          console.log('📺 Notified server of screen sharing stop');
        }
        
        // ===== WEBRTC P2P CLEANUP =====
        isScreenSharing = false;
        
        console.log('🛑 Screen sharing stopped');
        
        // Hide stop button, show share button
        document.getElementById('stop-sharing').style.display = 'none';
        document.getElementById('share-screen').style.display = 'inline-block';
      }
    }
    
    function loadVideoFile(file) {
      if (currentStream) stopScreenShare();
      
      const videoEl = document.getElementById('video-element');
      const url = URL.createObjectURL(file);
      videoEl.src = url;
      videoEl.loop = true;
      videoEl.muted = false; // Ensure audio is not muted
      videoEl.volume = 1.0; // Set volume to maximum
      
      currentVideo = { file: file, url: url };
      
      function updateVideoTexture() {
        if (videoEl.readyState >= videoEl.HAVE_CURRENT_DATA && largeScreen && largeScreen.canvas) {
          const ctx = largeScreen.canvas.getContext('2d');
          ctx.drawImage(videoEl, 0, 0, largeScreen.canvas.width, largeScreen.canvas.height);
          largeScreen.texture.needsUpdate = true;
        }
        
        if (currentVideo && !videoEl.paused) {
          requestAnimationFrame(updateVideoTexture);
        }
      }
      
      videoEl.addEventListener('loadeddata', () => {
        updateVideoTexture();
        
        // Create MediaStream from video element for WebRTC sharing
        if (socket && socket.connected) {
          try {
            // Create canvas for video stream with optimal dimensions
            const canvas = document.createElement('canvas');
            const videoCanvasSize = getOptimalCanvasSize(1920, 1080, isMobileEarly);
            canvas.width = videoCanvasSize.width;
            canvas.height = videoCanvasSize.height;
            console.log(`\ud83c\udfa5 Video canvas: ${canvas.width}x${canvas.height}`);
            const ctx = canvas.getContext('2d');
            
            // Function to draw video to canvas
            function drawVideoToCanvas() {
              if (videoEl.readyState >= videoEl.HAVE_CURRENT_DATA) {
                ctx.drawImage(videoEl, 0, 0, canvas.width, canvas.height);
              }
              if (currentVideo && !videoEl.paused) {
                requestAnimationFrame(drawVideoToCanvas);
              }
            }
            
            // Start drawing
            drawVideoToCanvas();
            
            // Capture canvas as stream
            const videoStream = canvas.captureStream(30); // 30 fps
            
            // Try to capture audio from the video element
            let audioStream = null;
            if (videoEl.captureStream) {
              // Modern browsers support captureStream on video elements
              const fullStream = videoEl.captureStream();
              const audioTracks = fullStream.getAudioTracks();
              if (audioTracks.length > 0) {
                audioStream = new MediaStream(audioTracks);
                console.log('🔊 Captured audio tracks from video:', audioTracks.length);
              }
            } else if (videoEl.mozCaptureStream) {
              // Firefox compatibility
              const fullStream = videoEl.mozCaptureStream();
              const audioTracks = fullStream.getAudioTracks();
              if (audioTracks.length > 0) {
                audioStream = new MediaStream(audioTracks);
                console.log('🔊 Captured audio tracks from video (Firefox):', audioTracks.length);
              }
            }
            
            // Combine video and audio streams
            if (audioStream) {
              audioStream.getAudioTracks().forEach(track => {
                videoStream.addTrack(track);
                console.log('🎵 Added audio track to stream');
              });
            } else {
              console.log('⚠️ No audio tracks found in video file');
            }
            
            currentStream = videoStream;
            isScreenSharing = true;
            
            // Notify server about video file sharing
            socket.emit('screen-share-start', {
              streamId: videoStream.id,
              hasVideo: true,
              hasAudio: audioStream !== null,
              isVideoFile: true,
              fileName: file.name
            });
            
            console.log('📹 Video file sharing started:', file.name);
            
            // Connect to existing users with P2P
            userAvatars.forEach((avatar, userId) => {
              if (userId !== myUserId) {
                console.log(`🔗 Connecting to ${userId} for video file sharing`);
                connectToPeer(userId, true);
              }
            });
            
            // Update UI
            document.getElementById('share-screen').style.display = 'none';
            document.getElementById('stop-sharing').style.display = 'inline-block';
            
          } catch (error) {
            console.error('❌ Failed to create stream from video file:', error);
          }
        }
      });
      
      videoEl.addEventListener('play', () => updateVideoTexture());
      
      videoEl.play();
      console.log('Video loaded:', file.name);
    }
    
    function clearScreen() {
      if (currentStream) stopScreenShare();
      
      if (currentVideo) {
        const videoEl = document.getElementById('video-element');
        videoEl.pause();
        videoEl.src = '';
        URL.revokeObjectURL(currentVideo.url);
        currentVideo = null;
        
        // Also stop any WebRTC sharing
        if (isScreenSharing) {
          stopScreenShare();
        }
      }
      
      resetScreenContent();
    }
    
    function resetScreenContent() {
      if (!largeScreen || !largeScreen.canvas) {
        console.warn('Cannot reset screen content - largeScreen not ready');
        return;
      }
      
      // Clean up any remote video elements
      const remoteVideo = document.getElementById('remote-screen-video');
      if (remoteVideo) {
        if (remoteVideo.srcObject) {
          remoteVideo.srcObject.getTracks().forEach(track => track.stop());
          remoteVideo.srcObject = null;
        }
        remoteVideo.remove();
        window.remoteVideoElement = null;
      }
      
      const ctx = largeScreen.canvas.getContext('2d');
      
      // Fill background
      ctx.fillStyle = '#001122';
      ctx.fillRect(0, 0, largeScreen.canvas.width, largeScreen.canvas.height);
      
      // Draw text content
      ctx.fillStyle = '#00ff00';
      const scale = largeScreen.canvas.width / 1920; // Scale relative to desktop size
      
      ctx.font = `bold ${Math.floor(72 * scale)}px Arial`;
      ctx.textAlign = 'center';
      ctx.fillText('LARGE DISPLAY SCREEN', largeScreen.canvas.width/2, largeScreen.canvas.height/2 - Math.floor(80 * scale));
      ctx.font = `bold ${Math.floor(48 * scale)}px Arial`;
      ctx.fillText('Ready for Screen Sharing or Video', largeScreen.canvas.width/2, largeScreen.canvas.height/2 + Math.floor(10 * scale));
      ctx.font = `${Math.floor(32 * scale)}px Arial`;
      ctx.fillText('Use controls to share desktop or load video', largeScreen.canvas.width/2, largeScreen.canvas.height/2 + Math.floor(80 * scale));
      
      largeScreen.texture.needsUpdate = true;
    }

    // User object position - positioned at couch facing the screen (further back and slightly higher)
    // Get space configuration for camera positions
    const spaceConfig = getCurrentSpaceConfig();
    
    // On mobile, use mobile camera position from config
    if (isMobileEarly || isRealIOS) {
      const pos = spaceConfig.mobileCameraPosition;
      userObject.position.set(pos.x, pos.y, pos.z);
      console.log(`📱 Mobile camera position: (${pos.x}, ${pos.y}, ${pos.z})`);
      
      // Show position in debug panel
      if (debugInfo) {
        debugInfo.performance['Camera'] = `X:${pos.x} Y:${pos.y} Z:${pos.z}`;
        updateDebugPanel();
      }
    } else {
      const pos = spaceConfig.cameraPosition;
      userObject.position.set(pos.x, pos.y, pos.z);
      console.log(`🖥️ Desktop camera position: (${pos.x}, ${pos.y}, ${pos.z})`);
    }
    
    // Camera is now at origin relative to user object
    camera.position.set(0, 0, 0);
    camera.lookAt(0, 0, -4); // Look forward relative to user object

    // Mobile controls
    let isMoving = false;
    let lastTap = 0;
    let cameraRotation = { x: 0, y: Math.PI };
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };

    // Screen dismissal functionality
    const screenElement = document.getElementById('interactive-screen');
    const dragOverlay = document.getElementById('drag-overlay');
    const modelControls = document.getElementById('model-controls');

    function hideScreen() {
      if (isScreenVisible) {
        screenElement.style.display = 'none';
        isScreenVisible = false;
      }
    }

    screenElement.addEventListener('click', hideScreen);

    // Object selection functions
    function checkObjectSelection(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(sceneObjects, true);
      
      if (intersects.length > 0) {
        let targetObject = intersects[0].object;
        
        while (targetObject.parent && !sceneObjects.includes(targetObject)) {
          targetObject = targetObject.parent;
        }
        
        if (sceneObjects.includes(targetObject)) {
          // Check if object is selectable (skip the share screen)
          if (targetObject.userData.isSelectable !== false) {
            selectObject(targetObject);
          }
        }
      } else {
        deselectObject();
      }
    }
    
    function selectObject(object) {
      if (selectedObject) clearSelection();
      
      selectedObject = object;
      addSelectionIndicator(object);
      modelControls.classList.add('visible');
      document.getElementById('selected-object-name').textContent = object.userData.name || 'Unknown Object';
    }
    
    function deselectObject() {
      if (selectedObject) {
        clearSelection();
        selectedObject = null;
        modelControls.classList.remove('visible');
      }
    }
    
    function clearSelection() {
      if (selectedOutline) {
        scene.remove(selectedOutline);
        selectedOutline = null;
      }
    }
    
    function addSelectionIndicator(object) {
      const geometry = object.geometry;
      if (geometry) {
        const wireframe = new THREE.WireframeGeometry(geometry);
        const outlineMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 3 });
        selectedOutline = new THREE.LineSegments(wireframe, outlineMaterial);
        
        selectedOutline.position.copy(object.position);
        selectedOutline.rotation.copy(object.rotation);
        selectedOutline.scale.copy(object.scale);
        
        scene.add(selectedOutline);
      }
    }

    // ===== SERVER-MEDIATED OBJECT MANIPULATION =====
    window.moveObject = function(direction) {
      if (!selectedObject || !socket) return;
      
      const moveAmount = 0.5;
      const newPosition = {
        x: selectedObject.position.x,
        y: selectedObject.position.y,
        z: selectedObject.position.z
      };
      
      switch(direction) {
        case 'up': newPosition.y += moveAmount; break;
        case 'down': newPosition.y -= moveAmount; break;
        case 'left': newPosition.x -= moveAmount; break;
        case 'right': newPosition.x += moveAmount; break;
        case 'forward': newPosition.z -= moveAmount; break;
        case 'backward': newPosition.z += moveAmount; break;
      }
      
      // Update the object locally first
      selectedObject.position.set(newPosition.x, newPosition.y, newPosition.z);
      
      // Send to server for persistence and sync
      socket.emit('object-move', {
        objectId: selectedObject.userData.objectId || generateObjectId(selectedObject),
        position: newPosition,
        rotation: {
          x: selectedObject.rotation.x,
          y: selectedObject.rotation.y,
          z: selectedObject.rotation.z
        },
        scale: {
          x: selectedObject.scale.x,
          y: selectedObject.scale.y,
          z: selectedObject.scale.z
        }
      });
    };

    window.scaleObject = function(direction) {
      if (!selectedObject || !socket) return;
      
      const scaleAmount = direction === 'up' ? 1.1 : 0.9;
      const newScale = {
        x: selectedObject.scale.x * scaleAmount,
        y: selectedObject.scale.y * scaleAmount,
        z: selectedObject.scale.z * scaleAmount
      };
      
      // Update the object locally first
      selectedObject.scale.set(newScale.x, newScale.y, newScale.z);
      
      socket.emit('object-move', {
        objectId: selectedObject.userData.objectId || generateObjectId(selectedObject),
        position: {
          x: selectedObject.position.x,
          y: selectedObject.position.y,
          z: selectedObject.position.z
        },
        rotation: {
          x: selectedObject.rotation.x,
          y: selectedObject.rotation.y,
          z: selectedObject.rotation.z
        },
        scale: newScale
      });
    };

    window.rotateObject = function(axis) {
      if (!selectedObject || !socket) return;
      
      const newRotation = {
        x: selectedObject.rotation.x,
        y: selectedObject.rotation.y,
        z: selectedObject.rotation.z
      };
      
      if (axis === 'y') {
        newRotation.y += Math.PI / 4;
      }
      
      // Update the object locally first
      selectedObject.rotation.set(newRotation.x, newRotation.y, newRotation.z);
      
      socket.emit('object-move', {
        objectId: selectedObject.userData.objectId || generateObjectId(selectedObject),
        position: {
          x: selectedObject.position.x,
          y: selectedObject.position.y,
          z: selectedObject.position.z
        },
        rotation: newRotation,
        scale: {
          x: selectedObject.scale.x,
          y: selectedObject.scale.y,
          z: selectedObject.scale.z
        }
      });
    };

    window.resetObject = function() {
      if (!selectedObject || !selectedObject.userData || !socket) return;
      
      const userData = selectedObject.userData;
      
      // Update the object locally first
      selectedObject.position.copy(userData.originalPosition);
      selectedObject.rotation.copy(userData.originalRotation);
      selectedObject.scale.copy(userData.originalScale);
      
      socket.emit('object-move', {
        objectId: selectedObject.userData.objectId || generateObjectId(selectedObject),
        position: {
          x: userData.originalPosition.x,
          y: userData.originalPosition.y,
          z: userData.originalPosition.z
        },
        rotation: {
          x: userData.originalRotation.x,
          y: userData.originalRotation.y,
          z: userData.originalRotation.z
        },
        scale: {
          x: userData.originalScale.x,
          y: userData.originalScale.y,
          z: userData.originalScale.z
        }
      });
    };
    
    window.deleteSelected = function() {
      if (!selectedObject || !socket) return;
      
      // Send deletion to server
      socket.emit('object-delete', {
        objectId: selectedObject.userData.objectId || generateObjectId(selectedObject)
      });
      
      // Local cleanup will happen when server confirms deletion
    };
    
    window.deselectObject = deselectObject;
    
    // ===== HELPER FUNCTIONS =====
    // Move this function early since it's used by object manipulation functions
    function generateObjectId(object) {
      if (!object.userData.objectId) {
        object.userData.objectId = `obj_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      }
      return object.userData.objectId;
    }
    
    function updateObjectInScene(objectId, state) {
      // Find object by ID
      const object = sceneObjects.find(obj => obj.userData.objectId === objectId);
      if (object) {
        object.position.set(state.position.x, state.position.y, state.position.z);
        object.rotation.set(state.rotation.x, state.rotation.y, state.rotation.z);
        object.scale.set(state.scale.x, state.scale.y, state.scale.z);
        
        // Update outline if this object is selected
        if (selectedObject === object && selectedOutline) {
          selectedOutline.position.copy(object.position);
          selectedOutline.rotation.copy(object.rotation);
          selectedOutline.scale.copy(object.scale);
        }
      }
    }
    
    function removeObjectFromScene(objectId) {
      // Find and remove object by ID
      const objectIndex = sceneObjects.findIndex(obj => obj.userData.objectId === objectId);
      if (objectIndex > -1) {
        const object = sceneObjects[objectIndex];
        
        // If this object is selected, deselect it
        if (selectedObject === object) {
          deselectObject();
        }
        
        // Remove from scene and array
        scene.remove(object);
        sceneObjects.splice(objectIndex, 1);
        
        console.log(`🗑️ Removed object ${objectId} from scene`);
      }
    }
    
    // ===== USER AVATAR SYSTEM =====
    const userAvatars = new Map();
    const customAvatarModels = new Map(); // Store custom avatar GLB models
    let myCustomAvatarUrl = null; // Store custom avatar data URL
    
    function spawnUserAvatar(userId, avatar) {
      if (userAvatars.has(userId)) return; // Already exists
      
      // Create avatar container group
      const avatarGroup = new THREE.Group();
      
      // Check if user has custom avatar
      if (avatar.customAvatarUrl) {
        // Load custom GLB model
        const loader = new GLTFLoader();
        loader.load(avatar.customAvatarUrl, (gltf) => {
          const model = gltf.scene;
          model.scale.set(0.5, 0.5, 0.5); // Scale down to appropriate size
          
          // Center the model
          const box = new THREE.Box3().setFromObject(model);
          const center = box.getCenter(new THREE.Vector3());
          model.position.sub(center);
          model.position.y = 0; // Keep at ground level
          
          // Add to avatar group
          avatarGroup.add(model);
          customAvatarModels.set(userId, model);
          
          // Update lighting for the model
          model.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
        }, 
        undefined,
        (error) => {
          console.error('Error loading custom avatar:', error);
          // Fall back to default sphere
          createDefaultAvatar(avatarGroup, avatar);
        });
      } else {
        // Create default sphere avatar
        createDefaultAvatar(avatarGroup, avatar);
      }
      
      avatarGroup.position.set(
        avatar.position.x, 
        avatar.position.y + 0.5, // Slightly above ground
        avatar.position.z
      );
      
      // Add name label
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 256;  // Square power-of-2
      canvas.height = 256; // Square power-of-2
      
      // Clear canvas
      context.fillStyle = 'rgba(0,0,0,0)';
      context.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw text centered in the square canvas
      context.font = '32px Arial';
      context.fillStyle = 'white';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(avatar.username, 128, 128);
      
      const labelTexture = new THREE.CanvasTexture(canvas);
      const labelMaterial = new THREE.SpriteMaterial({ map: labelTexture });
      const labelSprite = new THREE.Sprite(labelMaterial);
      labelSprite.position.set(0, 0.8, 0);
      labelSprite.scale.set(1, 1, 1); // Square aspect ratio
      
      avatarGroup.add(labelSprite);
      scene.add(avatarGroup);
      
      userAvatars.set(userId, {
        mesh: avatarGroup,
        label: labelSprite,
        username: avatar.username,
        customAvatarUrl: avatar.customAvatarUrl
      });
      
      console.log(`🧑‍🤝‍🧑 Spawned avatar for ${avatar.username}`);
    }
    
    function createDefaultAvatar(avatarGroup, avatar) {
      const avatarGeometry = new THREE.SphereGeometry(0.2, 8, 6);
      const avatarMaterial = new THREE.MeshBasicMaterial({ 
        color: Math.random() * 0xffffff,
        transparent: true,
        opacity: 0.8
      });
      const avatarMesh = new THREE.Mesh(avatarGeometry, avatarMaterial);
      avatarGroup.add(avatarMesh);
    }
    
    function moveUserAvatar(userId, position, rotation) {
      const avatar = userAvatars.get(userId);
      if (avatar) {
        avatar.mesh.position.set(position.x, position.y + 0.5, position.z);
        if (rotation) {
          avatar.mesh.rotation.set(rotation.x, rotation.y, rotation.z);
        }
      }
    }
    
    function removeUserAvatar(userId) {
      const avatar = userAvatars.get(userId);
      if (avatar) {
        scene.remove(avatar.mesh);
        userAvatars.delete(userId);
        console.log(`🗑️ Removed avatar for user ${userId}`);
      }
    }
    
    function updateAvatarLabel(userId, newName) {
      const avatar = userAvatars.get(userId);
      if (avatar && avatar.label) {
        // Update the canvas texture with new name
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 256;  // Square power-of-2
        canvas.height = 256; // Square power-of-2
        
        // Clear canvas
        context.fillStyle = 'rgba(0,0,0,0)';
        context.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw text centered in the square canvas
        context.font = '32px Arial';
        context.fillStyle = 'white';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(newName, 128, 128);
        
        const labelTexture = new THREE.CanvasTexture(canvas);
        // Configure for mobile if needed
        if (isMobileEarly || mobileSettings.isIOS || mobileSettings.isAndroid) {
          configureMobileTexture(labelTexture);
        }
        avatar.label.material.map = labelTexture;
        avatar.label.material.needsUpdate = true;
        
        console.log(`🏷️ Updated avatar label for ${userId}: ${newName}`);
      }
    }
    
    // ===== SCREEN SHARING HELPERS =====
    function handleRemoteScreenShare(data) {
      console.log('📺 Handling remote screen share:', data);
      
      // Show indicator that someone else is sharing
      if (data.applyToObject === 'SHARESCREEN-HERE' || data.userId !== myUserId) {
        // Find the large screen object
        const screenObject = sceneObjects.find(obj => obj.userData.objectId === 'SHARESCREEN-HERE');
        if (screenObject && largeScreen && largeScreen.canvas) {
          const ctx = largeScreen.canvas.getContext('2d');
          
          // Clear screen and show "Remote Sharing" message
          ctx.fillStyle = '#001122';
          ctx.fillRect(0, 0, largeScreen.canvas.width, largeScreen.canvas.height);
          
          // Add sharing indicator text
          ctx.fillStyle = '#00ff88';
          ctx.font = 'bold 64px Arial';
          ctx.textAlign = 'center';
          
          if (data.isVideoFile) {
            ctx.fillText('📹 VIDEO FILE SHARE', largeScreen.canvas.width/2, largeScreen.canvas.height/2 - 50);
          } else {
            ctx.fillText('🖥️ REMOTE SCREEN SHARE', largeScreen.canvas.width/2, largeScreen.canvas.height/2 - 50);
          }
          
          ctx.fillStyle = '#ffffff';
          ctx.font = '36px Arial';
          
          // Get username from userAvatars
          const sharingUser = userAvatars.get(data.userId);
          const username = sharingUser ? sharingUser.username : `User${data.userId.substr(0,4)}`;
          ctx.fillText(`Shared by: ${username}`, largeScreen.canvas.width/2, largeScreen.canvas.height/2 + 20);
          
          if (data.fileName) {
            ctx.font = '28px Arial';
            ctx.fillStyle = '#ffcc00';
            ctx.fillText(`File: ${data.fileName}`, largeScreen.canvas.width/2, largeScreen.canvas.height/2 + 60);
          }
          
          ctx.font = '24px Arial';
          ctx.fillStyle = '#888888';
          const audioText = data.hasAudio ? '🔊 Audio enabled' : '🔇 No audio';
          ctx.fillText(audioText, largeScreen.canvas.width/2, largeScreen.canvas.height/2 + 100);
          
          largeScreen.texture.needsUpdate = true;
          console.log('📺 Updated screen with remote sharing indicator');
        }
      }
    }
    
    function clearScreenShare(clearObject) {
      if (clearObject === 'SHARESCREEN-HERE') {
        if (largeScreen && largeScreen.canvas) {
          // Reset screen to default content
          const ctx = largeScreen.canvas.getContext('2d');
          ctx.fillStyle = '#000000';
          ctx.fillRect(0, 0, largeScreen.canvas.width, largeScreen.canvas.height);
          
          // Add default screen text
          ctx.fillStyle = '#333333';
          ctx.font = '48px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('🖥️ LARGE DISPLAY', largeScreen.canvas.width/2, largeScreen.canvas.height/2 - 20);
          ctx.font = '24px Arial';
          ctx.fillText('Ready for screen sharing or video', largeScreen.canvas.width/2, largeScreen.canvas.height/2 + 20);
          
          largeScreen.texture.needsUpdate = true;
          console.log('📺 Cleared screen share and reset to default');
        }
      }
    }
    
    // ===== CHAT SYSTEM HELPERS =====
    function displayChatMessage(message) {
      console.log(`💬 ${message.username}: ${message.message}`);
      
      const chatMessages = document.getElementById('chat-messages');
      if (!chatMessages) return;
      
      const messageElement = document.createElement('div');
      messageElement.className = message.isSystem ? 'chat-message system-message' : 'chat-message';
      
      const timestamp = new Date(message.timestamp || new Date()).toLocaleTimeString('en-US', { 
        hour12: false, 
        hour: '2-digit', 
        minute: '2-digit' 
      });
      
      if (message.isSystem) {
        messageElement.innerHTML = `
          <span class="timestamp">[${timestamp}]</span>
          <span class="system-content">🔔 ${message.message}</span>
        `;
        messageElement.style.color = '#FFA500';
        messageElement.style.fontStyle = 'italic';
      } else {
        messageElement.innerHTML = `
          <span class="timestamp">[${timestamp}]</span>
          <span class="username">${message.username}:</span>
          <span class="content">${message.message}</span>
        `;
      }
      
      chatMessages.appendChild(messageElement);
      
      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
      
      // Keep only last 50 messages for performance
      while (chatMessages.children.length > 50) {
        chatMessages.removeChild(chatMessages.firstChild);
      }
    }

    function sendChatMessage() {
      const chatInput = document.getElementById('chat-input');
      const message = chatInput.value.trim();
      
      if (!message || !socket || !socket.connected) return;
      
      socket.emit('chat-message', { message });
      chatInput.value = '';
    }

    function toggleChat() {
      const chatContainer = document.getElementById('chat-container');
      const chatToggle = document.getElementById('chat-toggle');
      
      if (chatContainer.classList.contains('hidden')) {
        chatContainer.classList.remove('hidden');
        chatToggle.textContent = '×';  // Show X when chat is visible
        chatToggle.classList.add('hide-chat');
        chatToggle.classList.remove('show-chat');
      } else {
        chatContainer.classList.add('hidden');
        chatToggle.textContent = '💬';  // Show chat icon when chat is hidden
        chatToggle.classList.add('show-chat');
        chatToggle.classList.remove('hide-chat');
      }
    }
    
    function showObjectsList() {
      const container = document.getElementById('objects-list-container');
      container.innerHTML = '';
      
      if (sceneObjects.length === 0) {
        container.innerHTML = '<p style="color: rgba(255,255,255,0.7); text-align: center;">No objects in the space</p>';
      } else {
        sceneObjects.forEach((obj, index) => {
          if (obj.userData && obj.userData.name) {
            const item = document.createElement('div');
            item.className = 'object-list-item';
            
            // Check if this is the display screen (type: 'display') - it shouldn't have a delete button
            if (obj.userData.type === 'display') {
              item.innerHTML = `
                <span>${obj.userData.name}</span>
                <span style="color: rgba(255,255,255,0.5); font-size: 12px;">Built-in</span>
              `;
            } else {
              item.innerHTML = `
                <span>${obj.userData.name}</span>
                <button class="object-delete-btn" data-index="${index}">🗑️ Delete</button>
              `;
              
              // Add delete event listener only for deletable objects
              item.querySelector('.object-delete-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                const objToDelete = sceneObjects[index];
                if (objToDelete && objToDelete.userData.objectId) {
                  // Send deletion to server
                  socket.emit('object-delete', {
                    objectId: objToDelete.userData.objectId
                  });
                  
                  // Remove from scene
                  scene.remove(objToDelete);
                  sceneObjects.splice(index, 1);
                  
                  // Refresh the list
                  showObjectsList();
                }
              });
            }
            
            container.appendChild(item);
          }
        });
      }
      
      document.getElementById('objects-list-dialog').classList.add('visible');
    }
    
    function getUserCount() {
      return userAvatars.size + 1; // +1 for current user
    }
    
    // ===== USER POSITION TRACKING =====
    let lastPositionUpdate = Date.now();
    let lastUserPosition = { x: 0, y: 0, z: 0 };
    let lastUserRotation = { x: 0, y: 0, z: 0 };
    
    function trackUserPosition() {
      if (!socket || !socket.connected) return;
      
      const now = Date.now();
      const timeDelta = now - lastPositionUpdate;
      
      // Only send updates every 100ms to avoid spam
      if (timeDelta < 100) return;
      
      const currentPosition = {
        x: Math.round(userObject.position.x * 100) / 100,
        y: Math.round(userObject.position.y * 100) / 100,
        z: Math.round(userObject.position.z * 100) / 100
      };
      
      const currentRotation = {
        x: Math.round(camera.rotation.x * 100) / 100,
        y: Math.round(camera.rotation.y * 100) / 100,
        z: Math.round(camera.rotation.z * 100) / 100
      };
      
      // Only send if position/rotation has changed significantly
      const positionChanged = 
        Math.abs(currentPosition.x - lastUserPosition.x) > 0.01 ||
        Math.abs(currentPosition.y - lastUserPosition.y) > 0.01 ||
        Math.abs(currentPosition.z - lastUserPosition.z) > 0.01;
        
      const rotationChanged = 
        Math.abs(currentRotation.x - lastUserRotation.x) > 0.01 ||
        Math.abs(currentRotation.y - lastUserRotation.y) > 0.01 ||
        Math.abs(currentRotation.z - lastUserRotation.z) > 0.01;
      
      if (positionChanged || rotationChanged) {
        socket.emit('user-move', {
          position: currentPosition,
          rotation: currentRotation
        });
        
        lastUserPosition = currentPosition;
        lastUserRotation = currentRotation;
        lastPositionUpdate = now;
      }
    }

    // Touch controls for mobile
    document.addEventListener('touchstart', (event) => {
      // Don't interfere with UI elements
      if (event.target.closest('.welcome-dialog') || 
          event.target.closest('.welcome-overlay') ||
          event.target.closest('.chat-container') ||
          event.target.closest('.chat-toggle') ||
          event.target.closest('.glass-menu') ||
          event.target.closest('.user-list') ||
          event.target.closest('.model-controls') ||
          event.target.closest('.screen-controls') ||
          event.target.closest('.help-dialog') ||
          event.target.closest('.objects-list-dialog')) {
        return; // Let UI elements handle their own touch events
      }
      
      if (event.touches.length === 1) {
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTap;
        
        if (tapLength < 500 && tapLength > 0) {
          isMoving = true;
          moveForward();
        }
        lastTap = currentTime;
        
        isDragging = true;
        previousMousePosition = {
          x: event.touches[0].clientX,
          y: event.touches[0].clientY
        };
      }
      event.preventDefault();
    });

    document.addEventListener('touchmove', (event) => {
      // Don't interfere with UI elements
      if (event.target.closest('.welcome-dialog') || 
          event.target.closest('.welcome-overlay') ||
          event.target.closest('.chat-container') ||
          event.target.closest('.chat-toggle') ||
          event.target.closest('.glass-menu') ||
          event.target.closest('.user-list') ||
          event.target.closest('.model-controls') ||
          event.target.closest('.screen-controls') ||
          event.target.closest('.help-dialog') ||
          event.target.closest('.objects-list-dialog')) {
        return; // Let UI elements handle their own touch events
      }
      
      if (isDragging && event.touches.length === 1) {
        const deltaMove = {
          x: event.touches[0].clientX - previousMousePosition.x,
          y: event.touches[0].clientY - previousMousePosition.y
        };
        
        cameraRotation.y -= deltaMove.x * 0.005;
        cameraRotation.x -= deltaMove.y * 0.005;
        cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotation.x));
        
        previousMousePosition = {
          x: event.touches[0].clientX,
          y: event.touches[0].clientY
        };
      }
      event.preventDefault();
    });

    document.addEventListener('touchend', (event) => {
      // Don't interfere with UI elements
      if (event.target.closest('.welcome-dialog') || 
          event.target.closest('.welcome-overlay') ||
          event.target.closest('.chat-container') ||
          event.target.closest('.chat-toggle') ||
          event.target.closest('.glass-menu') ||
          event.target.closest('.user-list') ||
          event.target.closest('.model-controls') ||
          event.target.closest('.screen-controls') ||
          event.target.closest('.help-dialog') ||
          event.target.closest('.objects-list-dialog')) {
        return; // Let UI elements handle their own touch events
      }
      
      isMoving = false;
      isDragging = false;
      event.preventDefault();
    });

    // Mouse controls for desktop
    document.addEventListener('mousedown', (event) => {
      if (event.target.closest('.model-controls') || event.target.closest('.controls-info') || event.target.closest('.screen-controls')) {
        return;
      }
      
      isDragging = true;
      previousMousePosition = { x: event.clientX, y: event.clientY };
      
      if (!isScreenVisible) {
        checkObjectSelection(event);
      }
    });

    document.addEventListener('mousemove', (event) => {
      if (isDragging) {
        const deltaMove = {
          x: event.clientX - previousMousePosition.x,
          y: event.clientY - previousMousePosition.y
        };
        
        cameraRotation.y -= deltaMove.x * 0.005;
        cameraRotation.x -= deltaMove.y * 0.005;
        cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotation.x));
        
        previousMousePosition = { x: event.clientX, y: event.clientY };
      }
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });

    // Keyboard controls
    const keys = {};
    document.addEventListener('keydown', (event) => {
      keys[event.code] = true;
      
      if (event.code === 'Enter' && isScreenVisible) {
        hideScreen();
        return;
      }
      
      if (!isScreenVisible && selectedObject) {
        switch(event.code) {
          case 'KeyR': resetObject(); break;
          case 'KeyQ': rotateObject('y'); break;
          case 'KeyE': scaleObject('up'); break;
          case 'KeyC': scaleObject('down'); break;
          case 'Delete':
          case 'Backspace': deleteSelected(); break;
          case 'Escape': deselectObject(); break;
        }
      }
    });

    document.addEventListener('keyup', (event) => {
      keys[event.code] = false;
    });

    function moveForward() {
      if (isMoving) {
        const direction = new THREE.Vector3(0, 0, -1);
        direction.applyQuaternion(camera.quaternion);
        userObject.position.add(direction.multiplyScalar(0.1));
        
        // Update position in debug panel on mobile
        if ((isMobileEarly || isRealIOS) && mobileDebugPanel) {
          const pos = userObject.position;
          debugInfo.performance['Camera'] = `X:${pos.x.toFixed(1)} Y:${pos.y.toFixed(1)} Z:${pos.z.toFixed(1)}`;
          updateDebugPanel();
        }
        
        requestAnimationFrame(moveForward);
      }
    }

    // Drag and drop functionality
    let dragCounter = 0;

    document.addEventListener('dragenter', (e) => {
      e.preventDefault();
      dragCounter++;
      if (dragCounter === 1) {
        dragOverlay.classList.add('active');
      }
    });

    document.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dragCounter--;
      if (dragCounter === 0) {
        dragOverlay.classList.remove('active');
      }
    });

    document.addEventListener('dragover', (e) => {
      e.preventDefault();
    });

    document.addEventListener('drop', (e) => {
      e.preventDefault();
      dragCounter = 0;
      dragOverlay.classList.remove('active');
      
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        const file = files[0];
        if (file.name.toLowerCase().endsWith('.glb') || file.name.toLowerCase().endsWith('.gltf')) {
          hideScreen();
          loadModelFromFile(file);
        } else {
          alert('Please drop a GLB or GLTF file');
        }
      }
    });

    // GLTF Loader
    const loader = new GLTFLoader();
    
    // Load the room model after loader is initialized
    loadRoomModel();

    async function loadModelFromFile(file) {
      // Show processing status
      showProcessingStatus('Processing GLB model...');
      
      try {
        // Process the GLB file
        const processed = await glbProcessor.processGLB(file, (progress) => {
          updateProcessingStatus(`Processing: ${progress.stage} (${Math.round(progress.progress)}%)`);
        });
        
        // Apply the processed model
        const version = (isMobile || isRealIOS) ? processed.mobile : processed.desktop;
        const model = version.scene.clone();
        
        model.position.set(0, 0.5, -3);
        model.scale.set(1, 1, 1);
        
        model.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            
            // Configure textures for mobile compatibility
            if (child.material) {
              // Handle different material types
              const materials = Array.isArray(child.material) ? child.material : [child.material];
              
              materials.forEach(material => {
                // Check all texture maps that might exist
                const textureProps = ['map', 'normalMap', 'roughnessMap', 'metalnessMap', 'emissiveMap', 'aoMap'];
                
                textureProps.forEach(prop => {
                  if (material[prop]) {
                    if (isMobileEarly || mobileSettings.isIOS || mobileSettings.isAndroid) {
                      configureMobileTexture(material[prop]);
                      console.log(`✅ Configured ${prop} for mobile on ${child.name || 'mesh'}`);
                    }
                  }
                });
              });
            }
          }
        });
        
        // Generate unique ID for this object
        const objectId = `obj_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        model.userData = {
          name: file.name.replace('.glb', '').replace('.gltf', ''),
          type: 'model',
          originalPosition: new THREE.Vector3(0, 0.5, -3),
          originalScale: new THREE.Vector3(1, 1, 1),
          originalRotation: new THREE.Euler(0, 0, 0),
          objectId: objectId  // Use the generated ID
        };
        
        scene.add(model);
        sceneObjects.push(model);
        selectObject(model);
        
        // Notify server of new object
        if (socket && socket.connected) {
          socket.emit('object-add', {
            objectId: model.userData.objectId,
            name: model.userData.name,
            type: model.userData.type,
            position: model.position,
            rotation: model.rotation,
            scale: model.scale
          });
        }
        
        hideProcessingStatus();
        console.log('Model loaded successfully:', file.name);
        
      } catch (error) {
        console.error('Error processing model:', error);
        hideProcessingStatus();
        alert('Error processing model: ' + error.message);
      }
    }

    // Upload model to cloud storage
    async function uploadModelToCloud(file) {
      // Show upload progress
      showProcessingStatus('Uploading GLB model to cloud...');
      
      try {
        // Validate file type
        if (!file.name.toLowerCase().endsWith('.glb')) {
          throw new Error('Only GLB files are supported for cloud upload');
        }
        
        // Validate file size (50MB limit)
        if (file.size > 50 * 1024 * 1024) {
          throw new Error('File size must be under 50MB');
        }
        
        // Get user info for authentication
        const userId = socket?.id || 'anonymous';
        const modelName = file.name.replace('.glb', '');
        
        // Create form data
        const formData = new FormData();
        formData.append('glbFile', file);
        formData.append('modelName', modelName);
        formData.append('userId', userId);
        
        // Upload to server
        updateProcessingStatus('Uploading to cloud storage...');
        
        const response = await fetch(`${SIGNALING_SERVER}/api/upload-model`, {
          method: 'POST',
          headers: {
            'X-User-ID': userId,
            // Don't set Content-Type - let browser set it for FormData
          },
          body: formData
        });
        
        const result = await response.json();
        
        if (!response.ok) {
          throw new Error(result.error || 'Upload failed');
        }
        
        updateProcessingStatus('Processing uploaded model...');
        
        // Load the uploaded model into the scene
        const loader = new THREE.GLTFLoader();
        
        loader.load(
          result.publicUrl,
          (gltf) => {
            const model = gltf.scene;
            
            // Position model
            model.position.set(0, 0.5, -3);
            model.scale.set(1, 1, 1);
            
            // Configure model for scene
            model.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                
                // Configure textures for mobile compatibility
                if (child.material) {
                  const materials = Array.isArray(child.material) ? child.material : [child.material];
                  
                  materials.forEach(material => {
                    const textureProps = ['map', 'normalMap', 'roughnessMap', 'metalnessMap', 'emissiveMap', 'aoMap'];
                    
                    textureProps.forEach(prop => {
                      if (material[prop]) {
                        if (isMobileEarly || mobileSettings.isIOS || mobileSettings.isAndroid) {
                          configureMobileTexture(material[prop]);
                        }
                      }
                    });
                  });
                }
              }
            });
            
            // Generate unique ID for this object
            const objectId = `obj_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            model.userData = {
              name: result.metadata.name,
              type: 'model',
              objectId: objectId,
              originalPosition: model.position.clone(),
              originalScale: model.scale.clone(),
              originalRotation: model.rotation.clone(),
              // Cloud model specific data
              isUploadedModel: true,
              modelId: result.modelId,
              modelUrl: result.publicUrl,
              uploadedBy: userId
            };
            
            scene.add(model);
            console.log('Cloud model added to scene:', model.userData.name);
            
            // Notify server of new object with cloud model info
            if (socket && socket.connected) {
              socket.emit('object-add', {
                objectId: objectId,
                name: model.userData.name,
                type: model.userData.type,
                position: model.position,
                rotation: model.rotation,
                scale: model.scale,
                // Cloud model specific fields
                modelId: result.modelId,
                modelUrl: result.publicUrl,
                uploadedBy: userId
              });
            }
            
            hideProcessingStatus();
            console.log('Cloud model loaded successfully:', result.metadata.name);
            alert(`Model "${result.metadata.name}" uploaded and loaded successfully!`);
          },
          (progress) => {
            // Loading progress
            const percent = (progress.loaded / progress.total) * 100;
            updateProcessingStatus(`Loading model: ${Math.round(percent)}%`);
          },
          (error) => {
            console.error('Error loading uploaded model:', error);
            hideProcessingStatus();
            alert('Model uploaded successfully but failed to load in scene. Check console for details.');
          }
        );
        
      } catch (error) {
        console.error('Error uploading model:', error);
        hideProcessingStatus();
        alert('Upload failed: ' + error.message);
      }
    }

    // Load uploaded model from world state (when joining)
    function loadUploadedModelFromWorldState(metadata) {
      // Check if model is already loaded to avoid duplicates
      const existingModel = scene.getObjectByName(`uploaded_${metadata.modelId}`);
      if (existingModel) {
        console.log('Model already loaded, skipping:', metadata.name);
        return;
      }
      
      console.log('Loading uploaded model from world state:', metadata.name);
      
      const loader = new THREE.GLTFLoader();
      
      loader.load(
        metadata.publicUrl,
        (gltf) => {
          const model = gltf.scene;
          
          // Set unique name for tracking
          model.name = `uploaded_${metadata.modelId}`;
          
          // Position model (this will be updated by object state if it exists)
          model.position.set(0, 0.5, -3);
          model.scale.set(1, 1, 1);
          
          // Configure model for scene
          model.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
              
              // Configure textures for mobile compatibility
              if (child.material) {
                const materials = Array.isArray(child.material) ? child.material : [child.material];
                
                materials.forEach(material => {
                  const textureProps = ['map', 'normalMap', 'roughnessMap', 'metalnessMap', 'emissiveMap', 'aoMap'];
                  
                  textureProps.forEach(prop => {
                    if (material[prop]) {
                      if (isMobileEarly || mobileSettings.isIOS || mobileSettings.isAndroid) {
                        configureMobileTexture(material[prop]);
                      }
                    }
                  });
                });
              }
            }
          });
          
          // Set up userData with cloud model info
          model.userData = {
            name: metadata.name,
            type: 'model',
            objectId: `uploaded_${metadata.modelId}`,
            originalPosition: model.position.clone(),
            originalScale: model.scale.clone(),
            originalRotation: model.rotation.clone(),
            // Cloud model specific data
            isUploadedModel: true,
            modelId: metadata.modelId,
            modelUrl: metadata.publicUrl,
            uploadedBy: metadata.uploadedBy
          };
          
          scene.add(model);
          console.log('Cloud model loaded from world state:', metadata.name);
        },
        (progress) => {
          // Loading progress
          console.log(`Loading ${metadata.name}: ${Math.round((progress.loaded / progress.total) * 100)}%`);
        },
        (error) => {
          console.error('Error loading uploaded model from world state:', error);
        }
      );
    }

    // Handle window resize
    // Research-backed resize handling for mobile compatibility
    function onWindowResize() {
      // Mobile-safe sizing
      const width = isMobile ? Math.min(window.innerWidth, 1024) : window.innerWidth;
      const height = isMobile ? Math.min(window.innerHeight, 1024) : window.innerHeight;
      
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
      
      if (composer) {
        composer.setSize(width, height);
      }
      
      console.log('Resized to:', width, 'x', height, 'Mobile:', isMobile);
    }
    
    window.addEventListener('resize', onWindowResize);

    // Animation loop with context loss tracking
    let firstRenderComplete = false;
    function animate() {
      window.animationId = requestAnimationFrame(animate);
      
      // Mark first successful render
      if (!firstRenderComplete && window.loadingStates) {
        firstRenderComplete = true;
        console.log('First render complete');
        // Give a moment for everything to settle
        setTimeout(() => {
          if (window.loadingStates && !window.loadingStates.roomLoaded) {
            window.loadingStates.sceneReady = true;
            window.checkLoadingComplete();
          }
        }, 100);
      }
      
      camera.rotation.order = 'YXZ';
      camera.rotation.y = cameraRotation.y;
      camera.rotation.x = cameraRotation.x;
      
      const moveSpeed = 0.1;
      if (keys['KeyW'] || keys['ArrowUp']) {
        const direction = new THREE.Vector3(0, 0, -1);
        direction.applyQuaternion(camera.quaternion);
        userObject.position.add(direction.multiplyScalar(moveSpeed));
      }
      if (keys['KeyS'] || keys['ArrowDown']) {
        const direction = new THREE.Vector3(0, 0, 1);
        direction.applyQuaternion(camera.quaternion);
        userObject.position.add(direction.multiplyScalar(moveSpeed));
      }
      if (keys['KeyA'] || keys['ArrowLeft']) {
        const direction = new THREE.Vector3(-1, 0, 0);
        direction.applyQuaternion(camera.quaternion);
        userObject.position.add(direction.multiplyScalar(moveSpeed));
      }
      if (keys['KeyD'] || keys['ArrowRight']) {
        const direction = new THREE.Vector3(1, 0, 0);
        direction.applyQuaternion(camera.quaternion);
        userObject.position.add(direction.multiplyScalar(moveSpeed));
      }
      
      
      // ===== USER POSITION TRACKING =====
      trackUserPosition();
      
      // Animate space environment effects
      const time = Date.now() * 0.001;
      
      if (window.auroraUniforms) {
        window.auroraUniforms.time.value = time;
      }
      
      if (window.nebula) {
        window.nebula.rotation.y += 0.0005;
      }
      
      if (window.lightParticles) {
        const positions = window.lightParticles.geometry.attributes.position.array;
        const velocities = window.lightParticles.userData.velocities;
        
        for (let i = 0; i < positions.length; i += 3) {
          positions[i] += velocities[i];
          positions[i + 1] += velocities[i + 1];
          positions[i + 2] += velocities[i + 2];
          
          // Wrap around
          if (Math.abs(positions[i]) > 50) velocities[i] *= -1;
          if (Math.abs(positions[i + 1]) > 50) velocities[i + 1] *= -1;
          if (Math.abs(positions[i + 2]) > 50) velocities[i + 2] *= -1;
        }
        
        window.lightParticles.geometry.attributes.position.needsUpdate = true;
        window.lightParticles.rotation.y += 0.001;
        window.lightParticles.rotation.x += 0.0005;
      }
      
      // Use composer for both mobile and desktop now
      if (composer) {
        composer.render();
      } else {
        // Fallback to direct rendering if composer fails
        renderer.render(scene, camera);
      }
    }

    // Add event listeners for control buttons
    ['move-up', 'move-down', 'move-left', 'move-right', 'move-forward', 'move-backward'].forEach(id => {
      document.getElementById(id).addEventListener('click', (e) => {
        e.stopPropagation();
        moveObject(id.split('-')[1]);
      });
    });
    
    ['scale-up', 'scale-down'].forEach(id => {
      document.getElementById(id).addEventListener('click', (e) => {
        e.stopPropagation();
        scaleObject(id.split('-')[1]);
      });
    });
    
    document.getElementById('rotate-y').addEventListener('click', (e) => {
      e.stopPropagation();
      rotateObject('y');
    });
    
    document.getElementById('reset-object').addEventListener('click', (e) => {
      e.stopPropagation();
      resetObject();
    });
    
    document.getElementById('delete-selected').addEventListener('click', (e) => {
      e.stopPropagation();
      deleteSelected();
    });
    
    document.getElementById('deselect-object').addEventListener('click', (e) => {
      e.stopPropagation();
      deselectObject();
    });

    // Popup menu system
    let activePopup = null;
    
    function showPopup(popupId) {
      // Close any active popup
      if (activePopup && activePopup !== popupId) {
        document.getElementById(activePopup).classList.remove('active');
      }
      
      // Toggle the requested popup
      const popup = document.getElementById(popupId);
      if (popup) {
        if (popup.classList.contains('active')) {
          popup.classList.remove('active');
          activePopup = null;
        } else {
          popup.classList.add('active');
          activePopup = popupId;
        }
      }
    }
    
    // Close popup when clicking outside
    document.addEventListener('click', (e) => {
      if (activePopup && !e.target.closest('.glass-menu') && !e.target.closest('.menu-popup')) {
        document.getElementById(activePopup).classList.remove('active');
        activePopup = null;
      }
    });
    
    // Glass menu event handlers with popup
    document.getElementById('menu-home').addEventListener('click', (e) => {
      e.stopPropagation();
      window.location.href = 'https://my-room.chat/';
    });
    
    document.getElementById('menu-screen').addEventListener('click', (e) => {
      e.stopPropagation();
      showPopup('screen-popup');
    });
    
    document.getElementById('menu-objects').addEventListener('click', (e) => {
      e.stopPropagation();
      showPopup('objects-popup');
    });
    
    document.getElementById('menu-help').addEventListener('click', (e) => {
      e.stopPropagation();
      showPopup('help-popup');
    });
    
    document.getElementById('help-close').addEventListener('click', (e) => {
      e.stopPropagation();
      document.getElementById('help-dialog').classList.remove('visible');
    });
    
    // GLB Upload from popup
    const glbUpload = document.getElementById('glb-upload');
    if (glbUpload) {
      glbUpload.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          loadModelFromFile(file);
          // Close the popup after loading
          if (activePopup) {
            document.getElementById(activePopup).classList.remove('active');
            activePopup = null;
          }
        }
      });
    }
    
    // Cloud GLB Upload from popup
    const glbCloudUpload = document.getElementById('glb-cloud-upload');
    if (glbCloudUpload) {
      glbCloudUpload.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
          await uploadModelToCloud(file);
          // Close the popup after upload attempt
          if (activePopup) {
            document.getElementById(activePopup).classList.remove('active');
            activePopup = null;
          }
        }
      });
    }
    
    // Room Model Upload from popup
    const roomUpload = document.getElementById('room-upload');
    if (roomUpload) {
      roomUpload.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
          showProcessingStatus('Processing room model...');
          
          try {
            // Process the room GLB file
            const processed = await glbProcessor.processGLB(file, (progress) => {
              updateProcessingStatus(`Processing room: ${progress.stage} (${Math.round(progress.progress)}%)`);
            });
            
            // Store as WEBROOM1 for future use
            glbProcessor.processedModels.set('WEBROOM1', processed);
            
            // Remove existing room model using tracked reference first
            if (currentRoomModel) {
              scene.remove(currentRoomModel);
              console.log('Removed tracked room model');
              currentRoomModel = null;
            }
            
            // Also check by name as backup
            const existingRoom = scene.getObjectByName('RoomModel');
            if (existingRoom) {
              scene.remove(existingRoom);
              console.log('Removed existing room model by name');
            }
            
            // Finally, remove any large mesh that might be the room (fallback)
            const objectsToRemove = [];
            scene.traverse((child) => {
              // Look for the room model characteristics
              if (child.name === 'RoomModel' || 
                  (child.type === 'Group' && child.children.length > 5) ||
                  (child.name && (child.name.includes('WEBROOM') || child.name.includes('BAKE')))) {
                objectsToRemove.push(child);
              }
            });
            
            objectsToRemove.forEach(obj => {
              scene.remove(obj);
              console.log(`Removed room object: ${obj.name || obj.type}`);
            });
            
            // Apply the new room model
            const roomModel = glbProcessor.applyProcessedModel(scene, processed, isMobile || isRealIOS);
            setupRoomModel(roomModel);
            
            hideProcessingStatus();
            console.log('Room model replaced successfully');
            
            // Notify other users if connected
            if (socket && socket.connected) {
              socket.emit('room-model-changed', {
                name: file.name,
                metadata: processed.metadata
              });
            }
            
          } catch (error) {
            console.error('Error processing room model:', error);
            hideProcessingStatus();
            alert('Error processing room model: ' + error.message);
          }
          
          e.target.value = ''; // Reset input
          // Close the popup after loading
          if (activePopup) {
            document.getElementById(activePopup).classList.remove('active');
            activePopup = null;
          }
        }
      });
    }
    
    // View Objects button removed - no longer in new popup system
    
    // Close objects list
    document.getElementById('objects-list-close').addEventListener('click', (e) => {
      e.stopPropagation();
      document.getElementById('objects-list-dialog').classList.remove('visible');
    });
    
    // Custom avatar upload removed
    
    // Screen control event listeners
    document.getElementById('share-screen').addEventListener('click', (e) => {
      e.stopPropagation();
      startScreenShare();
    });
    
    document.getElementById('stop-sharing').addEventListener('click', (e) => {
      e.stopPropagation();
      stopScreenShare();
    });
    
    document.getElementById('video-upload').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        loadVideoFile(file);
      }
    });
    
    // Load video button removed - using label wrapper instead
    
    document.getElementById('clear-screen').addEventListener('click', (e) => {
      e.stopPropagation();
      clearScreen();
    });

    // Audio control event listeners - add null checks since elements were removed
    let isAudioMuted = false;
    const toggleAudioBtn = document.getElementById('toggle-audio');
    if (toggleAudioBtn) {
      toggleAudioBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const videoEl = document.getElementById('video-element');
        const button = document.getElementById('toggle-audio');
        
        isAudioMuted = !isAudioMuted;
        videoEl.muted = isAudioMuted;
        
        // Also update all peer video elements
        document.querySelectorAll('video').forEach(video => {
          video.muted = isAudioMuted;
        });
        
        button.textContent = isAudioMuted ? '🔇 Audio OFF' : '🔊 Audio ON';
        console.log('Audio ' + (isAudioMuted ? 'muted' : 'unmuted'));
      });
    }
    
    const volumeSlider = document.getElementById('volume-slider');
    if (volumeSlider) {
      volumeSlider.addEventListener('input', (e) => {
        const volume = e.target.value / 100;
        const videoEl = document.getElementById('video-element');
        videoEl.volume = volume;
        
        // Also update all peer video elements
        document.querySelectorAll('video').forEach(video => {
          video.volume = volume;
        });
        
        console.log('Volume set to:', Math.round(volume * 100) + '%');
      });
    }

    // Chat interface event listeners
    document.getElementById('chat-send').addEventListener('click', (e) => {
      e.stopPropagation();
      sendChatMessage();
    });

    document.getElementById('chat-input').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        sendChatMessage();
      }
      e.stopPropagation(); // Prevent triggering 3D scene controls
    });

    document.getElementById('chat-toggle').addEventListener('click', (e) => {
      e.stopPropagation();
      toggleChat();
    });

    // User list close functionality
    document.getElementById('user-list-close').addEventListener('click', (e) => {
      e.stopPropagation();
      const userList = document.getElementById('user-list');
      const toggleButton = document.getElementById('users-toggle');
      
      // Hide user list and show toggle button
      userList.classList.add('collapsed');
      toggleButton.style.display = 'flex';
    });
    
    // Corner toggle buttons functionality
    document.getElementById('menu-toggle').addEventListener('click', (e) => {
      e.stopPropagation();
      const menu = document.getElementById('glass-menu');
      menu.classList.toggle('collapsed');
      
      // Close any active popup when closing the menu
      if (menu.classList.contains('collapsed') && activePopup) {
        document.getElementById(activePopup).classList.remove('active');
        activePopup = null;
      }
    });
    
    document.getElementById('users-toggle').addEventListener('click', (e) => {
      e.stopPropagation();
      const userList = document.getElementById('user-list');
      const toggleButton = document.getElementById('users-toggle');
      
      // Show user list and hide toggle button
      userList.classList.remove('collapsed');
      toggleButton.style.display = 'none';
    });
    
    // Add touch event support for mobile
    ['menu-toggle', 'users-toggle'].forEach(id => {
      const button = document.getElementById(id);
      button.addEventListener('touchend', (e) => {
        e.preventDefault();
        e.stopPropagation();
        button.click();
      });
    });


    // Note: Cloudflare Worker system removed - using Railway P2P WebRTC only
    
    // Note: initializeWorkerConnection removed - using Railway P2P only
    
    // Note: handleWorkerMessage removed - using Railway P2P only
    
    // Note: displayWorkerFrame removed - using Railway P2P only
    
    // Note: startWorkerBroadcast removed - using Railway P2P only
    
    // Note: stopWorkerBroadcast removed - using Railway P2P only
    
    // Note: loadCurrentWorkerFrame removed - using P2P WebRTC instead of worker frame streaming

    // Show welcome dialog first, then initialize room system
    showWelcomeDialog();
    
    // Additional check for page fully loaded
    window.addEventListener('load', () => {
      console.log('Page fully loaded');
      // If loading animation is still showing after page load, check completion
      setTimeout(() => {
        if (window.loadingStates && !window.loadingStates.roomLoaded) {
          console.log('Page loaded but room not ready, checking loading state...');
          window.checkLoadingComplete && window.checkLoadingComplete();
        }
      }, 1000);
    });
    
    // Initialize Cloudflare visitor counter immediately (Disabled)
    // initializeCloudflareVisitorCounter();
    
    // Note: Auto-loading current frame removed - using P2P WebRTC instead

    // Start the animation loop
    // Final mobile compatibility check before starting animation
    console.log('=== FINAL RENDER CHECK ===');
    console.log('Renderer ready:', !!renderer);
    console.log('Scene objects:', scene.children.length);
    console.log('Camera position:', camera.position);
    console.log('WebGL context valid:', !renderer.getContext().isContextLost());
    
    // Start animation with error handling
    try {
      animate();
      console.log('Animation loop started successfully');
    } catch (error) {
      console.error('Failed to start animation:', error);
      // Fallback: try to render one frame
      try {
        renderer.render(scene, camera);
        console.log('Single frame render successful');
      } catch (renderError) {
        console.error('Render failed completely:', renderError);
        document.body.innerHTML += '<div style="color: red; position: fixed; top: 10px; left: 10px;">Render Error: ' + renderError.message + '</div>';
      }
    }

    console.log('3D Interactive Website loaded successfully!');
  </script>
</body>
</html>